<!DOCTYPE html>
<html lang="en" class="figma-light">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Shade Perfection - Color Palette Generator</title>
  <style>
    /* ============================================================================
    SHADE PERFECTION - FIGMA PLUGIN
    by Nursultan Akim
    ============================================================================ */

    /* ============================================================================
    DESIGN TOKENS & CSS VARIABLES
    ============================================================================ */

    :root {
      /* Background Colors */
      --figma-color-bg: #ffffff;
      --figma-color-bg-secondary: #f3f3f3;
      --figma-color-bg-tertiary: #e6e6e6;
      --figma-color-bg-brand: #0d99ff;
      --figma-color-bg-hover: #f5f5f5;
      --figma-color-bg-pressed: #f5f5f5;

      /* Text Colors */
      --figma-color-text: #000000e5;
      --figma-color-text-secondary: #00000080;
      --figma-color-text-tertiary: #0000004d;
      --figma-color-text-onbrand: #ffffff;

      /* Border Colors */
      --figma-color-border: #e6e6e6;
      --figma-color-border-strong: #2c2c2c;

      /* Icon Colors */
      --figma-color-icon: #000000e5;
      --figma-color-icon-secondary: #00000080;
      --figma-color-icon-contrast: #555555;

      /* Spacing & Sizing */
      --spacing-xs: 1.5px;
      --spacing-sm: 3px;
      --spacing-md: 6px;
      --spacing-lg: 9px;
      --spacing-xl: 12px;
      --spacing-xxl: 18px;

      /* Border Radius */
      --radius-sm: 3px;
      --radius-md: 6px;
      --radius-lg: 9px;

      /* Transitions */
      --transition-fast: 0.15s ease;
      --transition-normal: 0.2s ease;
      --transition-slow: 0.3s ease;

      /* Shadows */
      --shadow-sm: 0 1.5px 6px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 3px 12px rgba(0, 0, 0, 0.15);
      --shadow-lg: 0 3px 15px rgba(0, 0, 0, 0.1);

      /* Z-index Layers */
      --z-base: 1;
      --z-curve: 5;
      --z-curve-secondary: 6;
      --z-points: 8;
      --z-points-secondary: 7;
      --z-handle: 10;
      --z-tooltip: 1000;
    }

    /* Dark Theme Variables */
    .figma-dark {
      --figma-color-bg: #2c2c2c;
      --figma-color-bg-secondary: #3c3c3c;
      --figma-color-bg-tertiary: #4c4c4c;
      --figma-color-text: #ffffffe5;
      --figma-color-text-secondary: #ffffff80;
      --figma-color-text-tertiary: #ffffff4d;
      --figma-color-border: #4c4c4c;
      --figma-color-border-strong: #666666;
      --figma-color-icon: #ffffffe5;
      --figma-color-icon-secondary: #ffffff80;
      --figma-color-icon-contrast: #999999;
    }

    /* ============================================================================
    GLOBAL RESET & BASE STYLES
    ============================================================================ */

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
    }

    /* Allow text selection in inputs */
    input[type="text"],
    input[type="number"],
    .color-value-editable {
      user-select: text;
    }

    /* Hide number input spinners */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    /* ============================================================================
    LAYOUT STRUCTURE
    ============================================================================ */

    body {
      font-family: "Inter", -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      padding: var(--spacing-xxl);
      gap: var(--spacing-xl);
      width: 462px;
      height: 462px;
      background: var(--figma-color-bg);
      border-radius: var(--spacing-md);
      position: relative;
      box-shadow: var(--shadow-lg);
    }

    /* Settings Panel (Left Side) */
    .settings {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0;
      gap: var(--spacing-xl);
      width: 204px;
      height: 426px;
    }

    /* Results Panel (Right Side) */
    .result {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      padding: 0;
      width: 214.5px;
      height: 426px;
      margin-left: calc(var(--spacing-xs) * -1);
      margin-right: calc(var(--spacing-sm) * -1.5);
    }

    /* ============================================================================
    INPUT CONTROLS
    ============================================================================ */

    .inputs {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0;
      gap: var(--spacing-md);
      width: 204px;
      height: 114px;
    }

    .input-row {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      padding: 0;
      width: 204px;
      height: 24px;
    }

    .input-label {
      font-size: 12px;
      line-height: 14px;
      color: var(--figma-color-text);
    }

    /* Standard Text Input */
    .input-field {
      display: flex;
      flex-direction: row;
      align-items: center;
      padding: 4.5px var(--spacing-md);
      gap: 7.5px;
      width: 128px;
      height: 24px;
      background: var(--figma-color-bg-secondary);
      border-radius: var(--radius-md);
      border: none;
      font-size: 12px;
      color: var(--figma-color-text);
      outline: none;
    }

    .input-field::placeholder {
      color: var(--figma-color-text-secondary);
    }

    .input-field:focus {
      outline: 1.5px solid var(--figma-color-bg-brand);
      outline-offset: 0;
    }

    /* ============================================================================
    COLOR INPUT COMPONENT
    ============================================================================ */

    .color-input {
      display: flex;
      flex-direction: row;
      align-items: center;
      padding: var(--spacing-sm);
      gap: 5px;
      width: 128px;
      height: 24px;
      background: var(--figma-color-bg-secondary);
      border-radius: var(--radius-md);
      transition: outline var(--transition-fast);
    }

    .color-input:focus-within {
      outline: 1.5px solid var(--figma-color-bg-brand);
      outline-offset: 0;
    }

    /* Error State */
    .color-input.error,
    .color-input.error:focus-within {
      outline: 1.5px solid #ff4757 !important;
      outline-offset: 0;
    }

    /* Color Preview Swatch */
    .color-preview {
      width: 16px;
      height: 16px;
      background: #077be4;
      border-radius: var(--radius-sm);
      flex-shrink: 0;
    }

    /* Color Input Wrapper */
    .color-input-wrapper {
      display: flex;
      align-items: center;
      flex: 1;
      background: transparent;
      min-width: 0;
    }

    .color-prefix {
      font-size: 12px;
      color: var(--figma-color-text-secondary);
      user-select: none;
      pointer-events: none;
      margin-right: 1.5px;
    }

    .color-suffix {
      font-size: 12px;
      color: var(--figma-color-text-secondary);
      user-select: none;
      pointer-events: none;
    }

    .color-value-editable {
      font-size: 12px;
      color: var(--figma-color-text);
      border: none;
      background: transparent;
      outline: none;
      min-width: 37.5px;
      width: auto;
      flex: 0 1 auto;
    }

    /* ============================================================================
    CONTRAST & NUMERIC INPUTS
    ============================================================================ */

    .contrast-input {
      display: flex;
      flex-direction: row;
      align-items: center;
      padding: 0;
      gap: 1px;
      width: 128px;
      height: 24px;
      background: var(--figma-color-bg-secondary);
      border-radius: var(--radius-md);
      transition: outline var(--transition-fast);
    }

    .contrast-input:focus-within {
      outline: 1.5px solid var(--figma-color-bg-brand);
      outline-offset: 0;
    }

    /* Disabled State */
    .contrast-input.disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .contrast-input.disabled:hover {
      outline: none;
    }

    /* Draggable Icon Controls */
    .contrast-input svg {
      cursor: ew-resize;
      user-select: none;
    }

    body.dragging .contrast-input svg {
      pointer-events: auto !important;
    }

    /* Generic Numeric Input */
    .color-value {
      font-size: 12px;
      color: var(--figma-color-text);
      border: none;
      background: transparent;
      flex: 1;
      outline: none;
    }

    .color-value:disabled {
      color: var(--figma-color-text-secondary);
      cursor: not-allowed;
    }

    .icon-input {
      width: 18px;
      height: 18px;
      fill: var(--figma-color-icon);
    }

    /* ============================================================================
    FEATURE TOGGLES (Previously Radio Buttons)
    ============================================================================ */

    .feature-toggles {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      padding: 0;
      gap: var(--spacing-md);
      width: 204px;
      height: 36px;
      position: relative;
    }

    .feature-toggle {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      padding: 4.5px;
      width: 36px;
      height: 36px;
      background: var(--figma-color-bg);
      border: 1.5px solid var(--figma-color-bg-secondary);
      border-radius: var(--radius-lg);
      cursor: pointer;
      transition: all var(--transition-normal);
    }

    .feature-toggle:hover {
      background: var(--figma-color-bg);
      border-color: var(--figma-color-bg-brand);
    }

    /* Active State */
    .feature-toggle.active {
      background: var(--figma-color-bg-brand);
      border-color: var(--figma-color-bg-brand);
    }

    .feature-toggle.active:hover {
      background: var(--figma-color-bg-brand);
      border-color: var(--figma-color-bg-brand);
    }

    /* Toggle Icons */
    .feature-toggle svg {
      width: 27px;
      height: 27px;
      fill: #8c8c8c;
      transition: fill var(--transition-normal);
    }

    .feature-toggle:hover svg {
      fill: var(--figma-color-bg-brand);
    }

    .feature-toggle.active svg {
      fill: var(--figma-color-text-onbrand);
    }

    .feature-toggle.active:hover svg {
      fill: var(--figma-color-text-onbrand);
    }

    /* ============================================================================
    ACTION BUTTONS
    ============================================================================ */

    .import-button {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      padding: 10.5px 57px;
      gap: 7.5px;
      width: 204px;
      height: 36px;
      background: var(--figma-color-bg-brand);
      border-radius: var(--radius-lg);
      border: none;
      cursor: pointer;
      font-size: 12px;
      color: var(--figma-color-text-onbrand);
      transition: background-color var(--transition-normal);
    }

    .import-button:hover {
      background: #007be5;
    }

    /* Disabled State */
    .import-button:disabled,
    .import-button.disabled {
      background: var(--figma-color-bg-secondary);
      color: var(--figma-color-text-tertiary);
      cursor: not-allowed;
      opacity: 0.6;
    }

    .import-button:disabled:hover,
    .import-button.disabled:hover {
      background: var(--figma-color-bg-secondary);
    }

    /* ============================================================================
    COLOR PICKER COMPONENTS
    ============================================================================ */

    .color-picker-area {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      padding: 0;
      gap: var(--spacing-md);
      width: 204px;
      height: 180px;
    }

    /* Hue Slider */
    .hue-slider {
      width: 18px;
      height: 180px;
      border-radius: var(--radius-sm);
      background: linear-gradient(180deg,
          #ff0000 0%,
          #ff6000 11.06%,
          #ffd900 22.12%,
          #00ff00 34.13%,
          #00cbff 47.6%,
          #003dff 61.06%,
          #a800ff 74.04%,
          #ff00ed 87.02%,
          #ff0000 100%);
      position: relative;
      cursor: pointer;
    }

    .hue-handle {
      position: absolute;
      width: 18px;
      height: 9px;
      border: 1.5px solid #ffffff;
      border-radius: var(--radius-sm);
      cursor: pointer;
      box-shadow: var(--shadow-sm);
    }

    /* Color Palette Canvas */
    .color-palette {
      width: 180px;
      height: 180px;
      border-radius: var(--radius-sm);
      background: linear-gradient(to right, #ffffff, #ff0000),
        linear-gradient(to top, #000000, transparent);
      position: relative;
      cursor: crosshair;
      overflow: hidden;
    }

    /* Darkness Gradient Overlay */
    .color-palette::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(to bottom, transparent, black);
      pointer-events: none;
    }

    /* Color Selection Handle */
    .color-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      border: 1.5px solid white;
      border-radius: 50%;
      cursor: grab;
      transform: translate(-50%, -50%);
      box-shadow: var(--shadow-sm);
      z-index: var(--z-handle);
      background: #077be4;
    }

    .color-handle:active {
      cursor: grabbing;
    }

    /* Distribution Points on Main Curve */
    .distribution-point {
      position: absolute;
      width: 6px;
      height: 6px;
      border: 0.75px solid white;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0.75px 3px rgba(0, 0, 0, 0.3);
      z-index: var(--z-points);
      pointer-events: none;
    }

    /* Superellipse Curve Visualization */
    .superellipse-curve {
      position: absolute;
      top: 0;
      left: 0;
      width: 180px;
      height: 180px;
      pointer-events: none;
      z-index: var(--z-curve);
    }

    /* Desaturated (Secondary) Curve Visualization */
    .desaturated-curve {
      position: absolute;
      top: 0;
      left: 0;
      width: 180px;
      height: 180px;
      pointer-events: none;
      z-index: var(--z-curve-secondary);
    }

    /* Distribution Points on Desaturated Curve */
    .distribution-point-secondary {
      position: absolute;
      width: 6px;
      height: 6px;
      border: 0.75px solid rgba(255, 255, 255, 0.75);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0.75px 3px rgba(0, 0, 0, 0.3);
      z-index: var(--z-points-secondary);
      pointer-events: none;
      opacity: 0.85;
    }

    /* ============================================================================
    SATURATION CONTROLS
    ============================================================================ */

    .saturation-controls {
      display: flex;
      flex-direction: row;
      align-items: center;
      padding: 0;
      gap: var(--spacing-md);
      width: 204px;
      height: 18px;
      margin-top: -6px;
    }

    /* Saturation Value Display */
    .saturation-value-display {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 18px;
      height: 18px;
      background: var(--figma-color-bg-secondary);
      border-radius: var(--radius-sm);
      font-size: 9px;
      line-height: 9px;
      color: var(--figma-color-text);
      font-weight: 500;
      user-select: none;
      flex-shrink: 0;
    }

    /* Saturation Slider */
    .saturation-slider {
      width: 180px;
      height: 18px;
      border-radius: var(--radius-sm);
      background: linear-gradient(90deg,
          #808080 0%,
          #077be4 100%);
      position: relative;
      cursor: pointer;
      flex-shrink: 0;
    }

    /* Saturation Handle */
    .saturation-handle {
      position: absolute;
      width: 9px;
      height: 18px;
      border: 1.5px solid #ffffff;
      border-radius: var(--radius-sm);
      cursor: pointer;
      box-shadow: var(--shadow-sm);
      top: 50%;
      transform: translate(-50%, -50%);
      left: 81%;
    }

    /* ============================================================================
    RESULTS PANEL & TAB NAVIGATION
    ============================================================================ */

    .top-bar {
      width: 214.5px;
      height: 42px;
      background: var(--figma-color-bg);
      position: relative;
      display: flex;
      justify-content: center;
    }

    /* Tab Switcher */
    .switch-toggle {
      width: 207px;
      height: 36px;
      background: var(--figma-color-bg-secondary);
      border-radius: var(--radius-lg);
      position: relative;
    }

    /* Animated Slide Indicator */
    .slide {
      position: absolute;
      width: 97.5px;
      height: 30px;
      left: 3px;
      top: 3px;
      background: var(--figma-color-bg);
      box-shadow: 0px 0px 3px rgba(0, 0, 0, 0.15);
      border-radius: var(--radius-md);
      transition: transform var(--transition-slow);
    }

    /* Tab Buttons */
    .toggle-button {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 7.5px 30px;
      position: absolute;
      width: 97.5px;
      height: 30px;
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 12px;
      z-index: var(--z-base);
      transition: color var(--transition-normal);
    }

    .toggle-button.active {
      color: var(--figma-color-text);
    }

    .toggle-button:not(.active) {
      color: var(--figma-color-text-secondary);
    }

    .result-button {
      left: 3px;
      top: 3px;
    }

    .resources-button {
      left: 105px;
      top: 3px;
    }

    /* Separator Line */
    .line {
      position: absolute;
      width: 207px;
      height: 1px;
      bottom: 0;
      border-bottom: 1px solid var(--figma-color-bg-secondary);
    }

    /* ============================================================================
    COLOR LIST DISPLAY
    ============================================================================ */

    .colors {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: var(--spacing-md);
      gap: var(--spacing-xs);
      width: 214px;
      height: 396px;
      overflow-y: auto;
      overflow-x: hidden;
      transition: opacity var(--transition-slow);
    }

    /* Individual Color Item */
    .color-preview-item {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      padding: 7.5px var(--spacing-lg);
      width: 204px;
      height: 30px;
      background: var(--figma-color-bg-tertiary);
      border-radius: var(--radius-md);
      margin-bottom: var(--spacing-xs);
      transition: background-color var(--transition-normal);
    }

    .color-name {
      font-size: 12px;
      color: var(--figma-color-text);
    }

    .color-hex {
      font-size: 12px;
      color: var(--figma-color-text);
      text-align: right;
      user-select: text;
    }

    /* ============================================================================
    PRESETS SECTION
    ============================================================================ */

    #presetsList {
      gap: 0px;
    }

    .presets-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 204px;
      height: 316px;
      gap: 3px;
      overflow-y: auto;
      overflow-x: hidden;
    }

    /* Preset Item Container */
    .preset-item {
      width: 204px;
      height: 30px;
      border-radius: var(--radius-md);
      position: relative;
      cursor: pointer;
      overflow: hidden;
      box-sizing: border-box;
      transition: transform 0.1s ease;
    }

    /* Color Spectrum Display */
    .preset-spectrum {
      display: flex;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    .spectrum-color {
      flex: 1;
      height: 100%;
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* Preset Info Overlay (Shown on Hover) */
    .preset-info {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 7.5px var(--spacing-lg);
      align-items: center;
      justify-content: space-between;
      box-sizing: border-box;
      margin: 0;
    }

    .preset-item:hover .preset-spectrum {
      display: none;
    }

    .preset-item:hover .preset-info {
      display: flex;
    }

    .preset-info * {
      font-size: 12px;
      color: white;
      margin: 0;
      padding: 0;
      line-height: 1;
    }

    .preset-contrast-container {
      display: flex;
      align-items: center;
      gap: 2px;
    }

    .preset-contrast-container svg {
      width: 18px;
      height: 18px;
      color: white;
      display: block;
    }

    .preset-saturation-container {
      gap: 4px;
    }

    .preset-saturation {
      font-size: 12px;
      color: white;
      margin: 0;
      padding: 0;
      line-height: 1;
    }

    /* ============================================================================
    INFO SECTION
    ============================================================================ */

    .info-section {
      margin-top: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 204px;
      height: 54px;
      gap: var(--spacing-md);
    }

    .info-item {
      display: flex;
      align-items: center;
      padding: 4px var(--spacing-md);
      gap: 2px;
      width: 204px;
      height: 24px;
      border-radius: var(--radius-md);
      font-size: 12px;
      text-decoration: none;
      background: var(--figma-color-bg-secondary);
      color: var(--figma-color-text);
    }

    .info-button {
      cursor: pointer;
      justify-content: space-between;
      transition: background-color var(--transition-slow);
    }

    .info-button:hover {
      background: var(--figma-color-bg-brand);
      color: white;
    }

    .info-item svg {
      width: 18px;
      height: 18px;
      stroke: var(--figma-color-icon);
      margin: 0px;
    }

    .info-button svg {
      stroke: var(--figma-color-text-secondary);
    }

    .info-button:hover svg {
      stroke: white;
    }

    /* ============================================================================
    CUSTOM SCROLLBARS
    ============================================================================ */

    /* Firefox */
    * {
      scrollbar-width: thin;
      scrollbar-color: var(--figma-color-bg-secondary) transparent;
    }

    /* Webkit (Chrome, Safari, Edge) */
    *::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    *::-webkit-scrollbar-track {
      background: transparent;
    }

    *::-webkit-scrollbar-thumb {
      background-color: var(--figma-color-bg-secondary);
      border-radius: var(--radius-sm);
      border: 1.5px solid transparent;
      background-clip: padding-box;
    }

    *::-webkit-scrollbar-thumb:hover {
      background-color: var(--figma-color-text-tertiary);
    }

    *::-webkit-scrollbar-corner {
      background: transparent;
    }

    /* Enhanced scrollbar for color list */
    .colors-list::-webkit-scrollbar {
      width: 9px;
      position: absolute;
    }

    .colors-list::-webkit-scrollbar-thumb {
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 4.5px;
      border: 2.25px solid transparent;
      background-clip: padding-box;
    }

    .colors-list::-webkit-scrollbar-thumb:hover {
      background-color: rgba(0, 0, 0, 0.4);
    }

    /* Dark theme scrollbar adjustments */
    .figma-dark .colors-list::-webkit-scrollbar-thumb {
      background-color: rgba(255, 255, 255, 0.2);
    }

    .figma-dark .colors-list::-webkit-scrollbar-thumb:hover {
      background-color: rgba(255, 255, 255, 0.5);
    }

    /* ============================================================================
    TOOLTIPS
    ============================================================================ */

    /* Standard Tooltip */
    .tooltip {
      position: absolute;
      background: var(--figma-color-bg);
      border: 1px solid var(--figma-color-border);
      border-radius: var(--radius-md);
      padding: var(--spacing-md) var(--spacing-lg);
      font-size: 11px;
      color: var(--figma-color-text);
      text-align: center;
      white-space: nowrap;
      box-shadow: var(--shadow-md);
      z-index: var(--z-tooltip);
      opacity: 0;
      visibility: hidden;
      transition: opacity var(--transition-fast), visibility var(--transition-fast);
      pointer-events: none;
    }

    .tooltip.show {
      opacity: 1;
      visibility: visible;
    }

    /* Tooltip Arrow */
    .tooltip::before {
      content: "";
      position: absolute;
      top: -5px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-bottom: 5px solid var(--figma-color-border);
    }

    .tooltip::after {
      content: "";
      position: absolute;
      top: -4px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-bottom: 4px solid var(--figma-color-bg);
    }

    /* Error Tooltip */
    .tooltip-error {
      position: absolute;
      background: #ff4757;
      border: 1px solid #ff3838;
      border-radius: var(--radius-md);
      padding: var(--spacing-md) var(--spacing-lg);
      font-size: 11px;
      color: #ffffff;
      text-align: center;
      user-select: none;
      box-shadow: 0 3px 12px rgba(255, 71, 87, 0.3);
      z-index: var(--z-tooltip);
      opacity: 0;
      visibility: hidden;
      transition: opacity var(--transition-fast), visibility var(--transition-fast);
      pointer-events: none;
    }

    .tooltip-error.show {
      opacity: 1;
      visibility: visible;
    }

    /* Error Tooltip Arrow */
    .tooltip-error::before {
      content: "";
      position: absolute;
      top: -5px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-bottom: 5px solid #ff3838;
    }

    .tooltip-error::after {
      content: "";
      position: absolute;
      top: -4px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-bottom: 4px solid #ff4757;
    }

    /* ============================================================================
    UTILITY CLASSES
    ============================================================================ */

    .focused {
      outline: 1.5px solid var(--figma-color-bg-brand);
      outline-offset: 0;
    }

    .disabled {
      opacity: 0.6;
      cursor: not-allowed;
      pointer-events: none;
    }

    /* ============================================================================
   END OF STYLESHEET
   ============================================================================ */
  </style>
</head>

<body>
  <div class="settings">
    <!-- Input Controls -->
    <div class="inputs">
      <!-- Color Name Input -->
      <div class="input-row">
        <label class="input-label">Color Name</label>
        <input type="text" class="input-field" placeholder="Deep Blue" id="colorName" />
      </div>

      <!-- Color Value Input -->
      <div class="input-row">
        <label class="input-label">Color</label>
        <div class="color-input">
          <div class="color-preview" id="colorPreview"></div>
          <div class="color-input-wrapper">
            <span class="color-prefix" id="colorPrefix">#</span>
            <input type="text" class="color-value-editable" value="4878d9" id="colorValue" />
            <span class="color-suffix" id="colorSuffix"></span>
          </div>
        </div>
      </div>

      <!-- Contrast Control -->
      <div class="input-row">
        <label class="input-label">Contrast</label>
        <div class="contrast-input">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"
            style="transform: scale(0.75);">
            <path
              d="M21.1836 12.9453C21.1836 7.9744 17.1545 3.94531 12.1846 3.94531C7.21463 3.94531 3.18555 7.9744 3.18555 12.9453C3.18555 17.9153 7.21463 21.9444 12.1846 21.9444C17.1545 21.9444 21.1836 17.9153 21.1836 12.9453Z"
              stroke="var(--figma-color-icon-contrast)" stroke-width="1.5" stroke-linecap="round"
              stroke-linejoin="round" />
            <path d="M12.1309 20.8749L21.1301 11.9922" stroke="var(--figma-color-icon-contrast)" stroke-width="1.5"
              stroke-linecap="round" stroke-linejoin="round" />
            <path d="M17.3949 5.60938L12.209 10.7369" stroke="var(--figma-color-icon-contrast)" stroke-width="1.5"
              stroke-linecap="round" stroke-linejoin="round" />
            <path d="M12.1602 15.8258L19.8462 8.2168" stroke="var(--figma-color-icon-contrast)" stroke-width="1.5"
              stroke-linecap="round" stroke-linejoin="round" />
            <path d="M12.1211 3.94531V21.9444" stroke="var(--figma-color-icon-contrast)" stroke-width="1.5"
              stroke-linecap="round" stroke-linejoin="round" />
          </svg>
          <input type="number" class="color-value" value="1.0" min="0.1" max="5.0" step="0.1" id="contrastInput" />
        </div>
      </div>

      <!-- Color Count Control -->
      <div class="input-row">
        <label class="input-label">Color Count</label>
        <div class="contrast-input">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"
            style="transform: scale(0.75);">
            <path
              d="M20.9996 7.78178V16.2158C20.9996 19.1637 18.9185 20.9986 15.9736 20.9986H8.02696C5.082 20.9986 3.00098 19.1637 3.00098 16.2148V7.78178C3.00098 4.83391 5.082 3 8.02696 3H15.9736C18.9185 3 20.9996 4.84266 20.9996 7.78178Z"
              stroke="var(--figma-color-icon-contrast)" stroke-width="1.5" stroke-linecap="round"
              stroke-linejoin="round" />
            <path d="M20.9898 15.0309H3M20.9898 8.98828H3" stroke="var(--figma-color-icon-contrast)" stroke-width="1.5"
              stroke-linecap="round" stroke-linejoin="round" />
          </svg>
          <input type="number" class="color-value" value="10" min="1" max="50" step="1" id="colorCount" />
        </div>
      </div>
    </div>

    <!-- Feature Toggles -->
    <div class="feature-toggles">
      <div class="feature-toggle active" data-feature="variables">
        <svg width="48" height="48" viewBox="2 3 31 31" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M29.5036 13.3428C29.5036 12.115 28.8483 10.9805 27.7849 10.3672L19.7204 5.70995C18.6563 5.09666 17.3449 5.09563 16.281 5.70898L16.282 5.70995L8.21652 10.3672C7.15416 10.9804 6.49882 12.1148 6.49875 13.3428V22.6562L6.50656 22.8848C6.58237 24.0231 7.21975 25.0563 8.21555 25.6328L16.282 30.2891L16.4841 30.3975C17.5085 30.9016 18.7229 30.8653 19.7204 30.2891L27.7839 25.6328L27.9782 25.5117C28.9271 24.8761 29.5035 23.8073 29.5036 22.6562V13.3428ZM31.0036 22.6562C31.0035 24.4203 30.0615 26.0492 28.5339 26.9316L20.4704 31.5879C19.0377 32.4155 17.2935 32.4674 15.822 31.7432L15.532 31.5879L7.46652 26.9326C6.03594 26.1053 5.11863 24.621 5.00949 22.9853L4.99875 22.6562V13.3428C4.99882 11.579 5.94006 9.94957 7.46652 9.06835L15.532 4.41113C17.0598 3.53017 18.9424 3.53021 20.4704 4.41113L28.5339 9.06835L28.8132 9.24218C30.1758 10.1538 31.0036 11.6892 31.0036 13.3428V22.6562Z" />
          <path
            d="M21.4011 17.999C21.4009 16.1205 19.8781 14.5986 17.9997 14.5986C16.1214 14.5988 14.5996 16.1206 14.5993 17.999C14.5993 19.8776 16.1212 21.4002 17.9997 21.4004C19.8783 21.4004 21.4011 19.8777 21.4011 17.999ZM22.9011 17.999C22.9011 20.7061 20.7067 22.9004 17.9997 22.9004C15.2928 22.9002 13.0993 20.706 13.0993 17.999C13.0996 15.2922 15.2929 13.0988 17.9997 13.0986C20.7066 13.0986 22.9009 15.2921 22.9011 17.999Z" />
        </svg>
      </div>
      <div class="feature-toggle" data-feature="reverse">
        <svg width="36" height="36" viewBox="2 3 31 31" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M9.0105 7.27368C9.20952 7.2739 9.40025 7.35344 9.54077 7.49438L14.0359 12.0032C14.3283 12.2964 14.328 12.7713 14.0349 13.0637C13.7417 13.356 13.2668 13.3557 12.9744 13.0627L9.00855 9.08423L5.03101 13.0627C4.73812 13.3556 4.26336 13.3556 3.97046 13.0627C3.67774 12.7698 3.67763 12.295 3.97046 12.0022L8.47925 7.49341C8.62004 7.35261 8.81139 7.27353 9.0105 7.27368Z" />
          <path
            d="M30.9704 22.9504C31.2633 22.6576 31.7381 22.6575 32.0309 22.9504C32.3238 23.2433 32.3238 23.7181 32.0309 24.011L27.5348 28.5061C27.2419 28.799 26.7672 28.799 26.4743 28.5061L21.9792 24.011C21.6863 23.7181 21.6863 23.2433 21.9792 22.9504C22.2721 22.6575 22.7468 22.6575 23.0397 22.9504L27.0046 26.9153L30.9704 22.9504Z" />
          <path
            d="M8.25952 21.8206V8.02368C8.25952 7.60947 8.59629 7.27368 9.0105 7.27368C9.42471 7.27368 9.75952 7.60947 9.75952 8.02368V21.8206C9.75952 23.2542 10.329 24.6291 11.3425 25.6428C12.3563 26.6566 13.732 27.2268 15.1658 27.2268H18.0007L18.0769 27.2307C18.4553 27.269 18.7507 27.5884 18.7507 27.9768C18.7507 28.3652 18.4552 28.6847 18.0769 28.7229L18.0007 28.7268H15.1658C13.3342 28.7268 11.5771 27.9995 10.282 26.7043C8.98684 25.4093 8.25952 23.6522 8.25952 21.8206Z" />
          <path
            d="M26.2562 27.9768V14.1799C26.2562 12.7463 25.6868 11.3715 24.6731 10.3577C23.6592 9.34381 22.2845 8.77372 20.8509 8.77368H18.0022C17.588 8.77368 17.2522 8.4379 17.2522 8.02368C17.2522 7.60947 17.588 7.27368 18.0022 7.27368H20.8509C22.6823 7.27372 24.4386 8.0013 25.7337 9.29614C27.0287 10.5912 27.7562 12.3483 27.7562 14.1799V27.9768C27.7561 28.3909 27.4203 28.7268 27.0062 28.7268C26.5922 28.7266 26.2562 28.3908 26.2562 27.9768Z" />
        </svg>
      </div>
      <div class="feature-toggle" data-feature="blackwhite">
        <svg width="36" height="36" viewBox="1 2 33 33" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M31.25 22C31.25 16.8914 27.1086 12.75 22 12.75C16.8914 12.75 12.75 16.8914 12.75 22C12.75 27.1086 16.8914 31.25 22 31.25C27.1086 31.25 31.25 27.1086 31.25 22ZM32.75 22C32.75 27.9371 27.9371 32.75 22 32.75C16.0629 32.75 11.25 27.9371 11.25 22C11.25 16.0629 16.0629 11.25 22 11.25C27.9371 11.25 32.75 16.0629 32.75 22Z" />
          <path
            d="M15 5C19.6071 5 23.4837 8.11632 24.6436 12.3555C23.8013 12.1251 22.9153 12 22 12C16.4772 12 12 16.4772 12 22C12 22.9153 12.1251 23.8013 12.3555 24.6436C8.11632 23.4837 5 19.6071 5 15C5 9.47715 9.47715 5 15 5Z" />
        </svg>
      </div>
      <div class="feature-toggle" data-feature="smartSpacing">
        <svg width="36" height="36" viewBox="1 3 33 33" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M19.8164 5.88278C21.8589 4.03923 24.9753 4.03908 27.0176 5.88278L27.2188 6.07321L30.9531 9.80954C33.0526 11.9091 33.0532 15.3138 30.9531 17.4121L30.9522 17.4111L16.9414 31.4248C14.8418 33.5244 11.4376 33.5244 9.3379 31.4248L5.60254 27.6884C3.50322 25.5901 3.50422 22.1861 5.60352 20.0869L19.6152 6.07321L19.8164 5.88278ZM26.0137 6.99704C24.5411 5.66745 22.2932 5.66755 20.8203 6.99704L20.6758 7.13474L6.66407 21.1474C5.15017 22.6613 5.14995 25.1157 6.66309 26.6279L10.3984 30.3642L10.543 30.5019C12.0647 31.8769 14.4143 31.8308 15.8809 30.3642L29.8926 16.3506C31.406 14.8384 31.4066 12.3841 29.8926 10.8701L26.1582 7.13474L26.0137 6.99704Z" />
          <path
            d="M18.7734 6.91404C19.0663 6.62115 19.541 6.62115 19.8339 6.91404L24.4589 11.539L24.5107 11.5957C24.751 11.8903 24.7335 12.325 24.4589 12.5996C24.166 12.8924 23.6912 12.8924 23.3984 12.5996L18.7734 7.97458C18.4805 7.68169 18.4805 7.20693 18.7734 6.91404Z" />
          <path
            d="M6.44239 19.2479C6.73528 18.9551 7.21004 18.9551 7.50293 19.2479L11.1006 22.8456L11.1523 22.9022C11.3926 23.1968 11.3751 23.6316 11.1006 23.9062C10.826 24.1807 10.3913 24.1981 10.0967 23.9579L10.04 23.9062L6.44239 20.3085C6.1495 20.0156 6.1495 19.5408 6.44239 19.2479Z" />
          <path
            d="M10.6069 15.082C10.8844 14.8106 11.3189 14.7978 11.6108 15.041L11.6675 15.0937L16.2427 19.7666C16.5324 20.0625 16.5269 20.5374 16.231 20.8271C15.935 21.1167 15.4601 21.1122 15.1704 20.8164L10.5952 16.1425L10.5444 16.0849C10.3076 15.7878 10.3296 15.3536 10.6069 15.082Z" />
          <path
            d="M14.6631 11.0244C14.956 10.7315 15.4307 10.7315 15.7236 11.0244L18.292 13.5927C18.5849 13.8856 18.5849 14.3604 18.292 14.6533C17.9991 14.9462 17.5243 14.9462 17.2314 14.6533L14.6631 12.0849C14.3702 11.792 14.3702 11.3173 14.6631 11.0244Z" />
        </svg>
      </div>
      <div class="feature-toggle" data-feature="rgb">
        <svg width="36" height="36" viewBox="2 3 31 31" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M4.28365 24V13.8182H7.91291C8.70173 13.8182 9.35633 13.954 9.87669 14.2258C10.4004 14.4976 10.7915 14.8738 11.05 15.3544C11.3085 15.8317 11.4378 16.3835 11.4378 17.0099C11.4378 17.633 11.3068 18.1816 11.045 18.6555C10.7865 19.1262 10.3954 19.4924 9.87171 19.7542C9.35135 20.0161 8.69676 20.147 7.90794 20.147H5.15865V18.8246H7.76873C8.26589 18.8246 8.67025 18.7533 8.9818 18.6108C9.29667 18.4683 9.52702 18.2611 9.67285 17.9893C9.81868 17.7175 9.8916 17.3911 9.8916 17.0099C9.8916 16.6255 9.81703 16.2924 9.66788 16.0106C9.52205 15.7289 9.2917 15.5135 8.97683 15.3643C8.66527 15.2119 8.25595 15.1356 7.74884 15.1356H5.81987V24H4.28365ZM9.30992 19.4062L11.8255 24H10.0755L7.60964 19.4062H9.30992Z" />
          <path
            d="M20.1977 17.0348C20.1016 16.7332 19.9723 16.463 19.8099 16.2244C19.6508 15.9825 19.4603 15.777 19.2382 15.6079C19.0161 15.4356 18.7626 15.3047 18.4775 15.2152C18.1958 15.1257 17.8859 15.0809 17.5479 15.0809C16.9745 15.0809 16.4574 15.2284 15.9967 15.5234C15.536 15.8184 15.1714 16.2509 14.903 16.821C14.6378 17.3878 14.5052 18.0821 14.5052 18.9041C14.5052 19.7294 14.6395 20.4271 14.9079 20.9971C15.1764 21.5672 15.5443 21.9997 16.0116 22.2947C16.479 22.5897 17.0109 22.7372 17.6075 22.7372C18.161 22.7372 18.6433 22.6245 19.0542 22.3991C19.4685 22.1737 19.7884 21.8556 20.0138 21.4446C20.2425 21.0303 20.3568 20.5431 20.3568 19.9829L20.7545 20.0575H17.8412V18.7898H21.8433V19.9481C21.8433 20.8032 21.661 21.5457 21.2964 22.1754C20.9352 22.8018 20.4347 23.2857 19.795 23.6271C19.1586 23.9685 18.4295 24.1392 17.6075 24.1392C16.6861 24.1392 15.8774 23.9271 15.1814 23.5028C14.4887 23.0786 13.9484 22.477 13.5606 21.6981C13.1729 20.9159 12.979 19.9879 12.979 18.914C12.979 18.102 13.0916 17.3728 13.317 16.7265C13.5424 16.0802 13.8589 15.5317 14.2666 15.0809C14.6776 14.6269 15.1598 14.2805 15.7133 14.0419C16.2702 13.7999 16.8783 13.679 17.5379 13.679C18.0881 13.679 18.6002 13.7602 19.0741 13.9226C19.5514 14.085 19.9756 14.3153 20.3469 14.6136C20.7214 14.9119 21.0313 15.2666 21.2765 15.6775C21.5218 16.0852 21.6875 16.5376 21.7737 17.0348H20.1977Z" />
          <path
            d="M23.7934 24V13.8182H27.5221C28.2446 13.8182 28.8429 13.9375 29.3168 14.1761C29.7908 14.4114 30.1454 14.7313 30.3808 15.1356C30.6161 15.5367 30.7338 15.9891 30.7338 16.4929C30.7338 16.9171 30.6559 17.2751 30.5001 17.5667C30.3443 17.8551 30.1355 18.0871 29.8737 18.2628C29.6151 18.4351 29.3301 18.5611 29.0186 18.6406V18.74C29.3566 18.7566 29.6864 18.866 30.0079 19.0682C30.3327 19.267 30.6012 19.5504 30.8133 19.9183C31.0254 20.2862 31.1315 20.7336 31.1315 21.2606C31.1315 21.781 31.0088 22.2483 30.7636 22.6626C30.5216 23.0736 30.1471 23.4001 29.64 23.642C29.1329 23.8807 28.4849 24 27.6961 24H23.7934ZM25.3296 22.6825H27.547C28.2828 22.6825 28.8097 22.54 29.1279 22.2549C29.4461 21.9699 29.6052 21.6136 29.6052 21.1861C29.6052 20.8646 29.524 20.5696 29.3616 20.3011C29.1992 20.0326 28.9672 19.8189 28.6656 19.6598C28.3673 19.5007 28.0126 19.4211 27.6017 19.4211H25.3296V22.6825ZM25.3296 18.223H27.3879C27.7326 18.223 28.0425 18.1567 28.3176 18.0241C28.596 17.8916 28.8164 17.7059 28.9788 17.4673C29.1445 17.2254 29.2274 16.9403 29.2274 16.6122C29.2274 16.1913 29.0799 15.8383 28.7849 15.5532C28.4899 15.2682 28.0375 15.1257 27.4276 15.1257H25.3296V18.223Z" />
        </svg>
      </div>
    </div>

    <!-- Tooltips -->
    <div class="tooltip" id="customTooltip"></div>
    <div class="tooltip-error" id="errorTooltip"></div>

    <!-- Import Button -->
    <button class="import-button" id="importButton">Import to Figma</button>

    <!-- Color Picker Area -->
    <div class="color-picker-area">
      <div class="hue-slider" id="hueSlider">
        <div class="hue-handle" id="hueHandle"></div>
      </div>
      <div class="color-palette" id="colorPalette">
        <div class="color-handle" id="colorHandle"></div>
      </div>
    </div>

    <!-- Saturation Controls -->
    <div class="saturation-controls">
      <div class="saturation-value-display" id="saturationValueDisplay">60</div>
      <div class="saturation-slider" id="saturationSlider">
        <div class="saturation-handle" id="saturationHandle"></div>
      </div>
    </div>
  </div>

  <!-- Result Section -->
  <div class="result">
    <!-- Top Bar with Tab Switcher -->
    <div class="top-bar">
      <div class="switch-toggle">
        <div class="slide" id="toggleSlide"></div>
        <button class="toggle-button result-button active" data-tab="result">Result</button>
        <button class="toggle-button resources-button" data-tab="presets">Presets</button>
      </div>
      <div class="line"></div>
    </div>

    <!-- Generated Colors List -->
    <div class="colors" id="colorsList"></div>

    <!-- Presets List -->
    <div class="colors" id="presetsList" style="display: none;">
      <div class="presets-section">
        <!-- Preset items will be generated by PresetManager -->
      </div>
      <div class="info-section">
        <a href="https://bento.me/ninsent" target="_blank" class="info-item info-button">
          <svg width="24" height="24" viewBox="2 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path fill="none" clip-rule="evenodd"
              d="M9 3C12.7282 3 15.75 6.02181 15.75 9.75C15.75 13.4782 12.7282 16.5 9 16.5C5.27181 16.5 2.25 13.4782 2.25 9.75C2.25 6.02181 5.27181 3 9 3Z"
              stroke-width="1.125" stroke-linecap="round" stroke-linejoin="round" />
            <path fill="none" clip-rule="evenodd"
              d="M8.99955 3C10.3875 3 11.512 6.02181 11.512 9.75C11.512 13.4782 10.3875 16.5 8.99955 16.5C7.6116 16.5 6.48706 13.4782 6.48706 9.75C6.48706 6.02181 7.6116 3 8.99955 3Z"
              stroke-width="1.125" stroke-linecap="round" stroke-linejoin="round" />
            <path fill="none" d="M2.25 9.74866H15.75" stroke-width="1.125" stroke-linecap="round"
              stroke-linejoin="round" />
          </svg>
          <span>Creator's page</span>
          <svg width="24" height="24" viewBox="-2 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M5.25 13L12.75 5.5M12.75 5.5H6.75M12.75 5.5V11.5" stroke-width="1.25" stroke-linecap="round"
              stroke-linejoin="round" />
          </svg>
        </a>
        <div class="info-item info-container">
          <svg width="18" height="18" viewBox="1.5 -0.5 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M11.2498 6.75C10.0078 6.75 9 7.75702 9 8.99977C9 10.2424 10.007 11.2495 11.2498 11.2495C12.4925 11.2495 13.5002 10.2424 13.5002 8.99977C13.5002 7.75702 12.4925 6.75 11.2498 6.75Z"
              fill="none" stroke-width="1.125" stroke-linecap="round" stroke-linejoin="round" />
            <path d="M4.5 9C4.5 7.75736 5.50736 6.75 6.75 6.75H9V11.25H6.75C5.50736 11.25 4.5 10.2426 4.5 9V9Z"
              fill="none" stroke-width="1.125" />
            <path d="M4.5 4.5C4.5 3.25736 5.50736 2.25 6.75 2.25H9V6.75H6.75C5.50736 6.75 4.5 5.74264 4.5 4.5V4.5Z"
              fill="none" stroke-width="1.125" />
            <path d="M9 2.25H11.25C12.4926 2.25 13.5 3.25736 13.5 4.5V4.5C13.5 5.74264 12.4926 6.75 11.25 6.75H9V2.25Z"
              fill="none" stroke-width="1.125" />
            <path
              d="M4.5 13.5C4.5 12.2574 5.50736 11.25 6.75 11.25H9V13.5C9 14.7426 7.99264 15.75 6.75 15.75V15.75C5.50736 15.75 4.5 14.7426 4.5 13.5V13.5Z"
              fill="none" stroke-width="1.125" />
          </svg>
          <span style="color: var(--figma-color-text-secondary); padding-right: 2px;">plugin version:</span>
          <span style="font-weight: 500;">1.2.0</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================================================
    // SHADE PERFECTION - FIGMA PLUGIN
    // by Nursultan Akim
    //
    // Sections:
    // 1. Configuration & Constants
    // 2. Color Mathematics Module
    // 3. Superellipse Mathematics Module
    // 4. Color Palette Generator
    // 5. Application State Manager
    // 6. Color Picker Controller
    // 7. UI Controller
    // 8. Preset Manager
    // ============================================================================

    'use strict';

    // ============================================================================
    // CONFIGURATION & CONSTANTS
    // ============================================================================

    const CONFIG = {
      // Canvas dimensions
      PALETTE_SIZE: 180,
      HUE_SLIDER_SIZE: 180,

      // Curve calculation
      CURVE_RESOLUTION: 400,
      SUPERELLIPSE_N_MIN: 0.1,
      SUPERELLIPSE_N_MAX: 25,
      SUPERELLIPSE_TOLERANCE: 0.001,
      SUPERELLIPSE_MAX_ITERATIONS: 100,

      // Input constraints
      CONTRAST_MIN: 0.1,
      CONTRAST_MAX: 5.0,
      CONTRAST_STEP: 0.1,
      COLOR_COUNT_MIN: 1,
      COLOR_COUNT_MAX: 50,

      // Saturation control
      SATURATION_MIN: 0,
      SATURATION_MAX: 100,
      SATURATION_DEFAULT: 100,
      SATURATION_MIN_THRESHOLD: 1,

      // UI interactions
      DRAG_SENSITIVITY: 0.3,
      TOOLTIP_DELAY: 1000,
      ERROR_TOOLTIP_DELAY: 500,
      TAB_TRANSITION_DELAY: 150,

      // Visual styles
      CURVE_STROKE_WIDTH: 2,
      CURVE_PRIMARY_OPACITY: 0.9,
      CURVE_SECONDARY_OPACITY: 0.4,
      POINT_SECONDARY_OPACITY: 0.85,
    };

    const FEATURE_TOOLTIPS = {
      variables: 'Import with<br>variables',
      reverse: 'Reverse order',
      blackwhite: 'Include black<br>and white',
      smartSpacing: 'Smart Spacing',
      rgb: 'RGB format'
    };

    const PRESET_DATA = {
      'Warm-Gray': { name: 'Warm Gray', color: '#BF3F1F', contrast: 1, saturation: 10 },
      'Cool-Gray': { name: 'Cool Gray', color: '#1F54BF', contrast: 1, saturation: 30 },
      'Atlantic-Blue': { name: 'Atlantic Blue', color: '#105FE7', contrast: 0.8, saturation: 100 },
      'Himmel-Blue': { name: 'Himmel Blue', color: '#18A2CC', contrast: 1.2, saturation: 100 },
      'Steppe-Green': { name: 'Steppe Green', color: '#25C454', contrast: 1.4, saturation: 100 },
      'Wheat-Yellow': { name: 'Wheat Yellow', color: '#D5AF1B', contrast: 1, saturation: 100 },
      'Fox-Orange': { name: 'Fox Orange', color: '#E36912', contrast: 0.7, saturation: 100 },
      'Santa-Red': { name: 'Santa Red', color: '#D91E28', contrast: 0.8, saturation: 100 },
      'Sakura-Magenta': { name: 'Sakura Pink', color: '#CC27AB', contrast: 1.2, saturation: 100 },
      'Amethyst-Purple': { name: 'Amethyst Purple', color: '#7102EF', contrast: 0.9, saturation: 100 },
    };

    // ============================================================================
    // COLOR MATHEMATICS MODULE
    // Handles all color space conversions (HSV, RGB, HEX)
    // ============================================================================

    class ColorMath {
      /**
       * Converts HSV color to HEX format
       * @param {number} h - Hue (0-360)
       * @param {number} s - Saturation (0-100)
       * @param {number} v - Value/Brightness (0-100)
       * @returns {string} HEX color string (#RRGGBB)
       */
      static hsvToHex(h, s, v) {
        s /= 100;
        v /= 100;
        const c = v * s;
        const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
        const m = v - c;

        let r, g, b;
        if (h < 60) [r, g, b] = [c, x, 0];
        else if (h < 120) [r, g, b] = [x, c, 0];
        else if (h < 180) [r, g, b] = [0, c, x];
        else if (h < 240) [r, g, b] = [0, x, c];
        else if (h < 300) [r, g, b] = [x, 0, c];
        else [r, g, b] = [c, 0, x];

        return '#' + [r, g, b]
          .map(val => Math.round((val + m) * 255).toString(16).padStart(2, '0'))
          .join('')
          .toUpperCase();
      }

      /**
       * Converts HEX color to HSV format
       * @param {string} hex - HEX color string
       * @returns {Object} HSV object {h, s, v}
       */
      static hexToHsv(hex) {
        const [r, g, b] = [1, 3, 5].map(i => parseInt(hex.slice(i, i + 2), 16) / 255);
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const diff = max - min;

        let h = 0;
        if (diff) {
          if (max === r) h = ((g - b) / diff) % 6;
          else if (max === g) h = (b - r) / diff + 2;
          else h = (r - g) / diff + 4;
        }
        h = Math.round(h * 60);
        if (h < 0) h += 360;

        return {
          h,
          s: Math.round(max ? (diff / max) * 100 : 0),
          v: Math.round(max * 100)
        };
      }

      /**
       * Converts HEX color to RGB format
       * @param {string} hex - HEX color string
       * @returns {Object} RGB object {r, g, b} (0-255)
       */
      static hexToRgb(hex) {
        return {
          r: parseInt(hex.substr(1, 2), 16),
          g: parseInt(hex.substr(3, 2), 16),
          b: parseInt(hex.substr(5, 2), 16)
        };
      }

      /**
       * Converts RGB color to HSV format
       * @param {number} r - Red (0-255)
       * @param {number} g - Green (0-255)
       * @param {number} b - Blue (0-255)
       * @returns {Object} HSV object {h, s, v}
       */
      static rgbToHsv(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const diff = max - min;

        let h = 0;
        if (diff !== 0) {
          if (max === r) h = ((g - b) / diff) % 6;
          else if (max === g) h = (b - r) / diff + 2;
          else h = (r - g) / diff + 4;
        }
        h = Math.round(h * 60);
        if (h < 0) h += 360;

        return {
          h,
          s: Math.round(max === 0 ? 0 : (diff / max) * 100),
          v: Math.round(max * 100)
        };
      }

      /**
       * Calculate desaturated version of a color by projecting onto a compressed superellipse curve.
       * This creates a palette with reduced saturation while maintaining the color relationships.
       * 
       * @param {number} h - Hue (0-360)
       * @param {number} s - Saturation (0-100)
       * @param {number} v - Value/Brightness (0-100)
       * @param {number} saturationPercent - Target saturation percentage (0-100)
       * @returns {string} HEX color string for desaturated color
       */
      static getDesaturatedColor(h, s, v, saturationPercent) {
        if (saturationPercent >= CONFIG.SATURATION_MAX) {
          return this.hsvToHex(h, s, v);
        }

        const x = s / 100;
        const y = v / 100;

        const n = SuperellipseMath.findExponent(x, y);
        const mainCurve = SuperellipseMath.generateCurvePoints(n);
        const selectedPoint = SuperellipseMath.findClosestPoint(x, y, mainCurve);
        const arcLength = selectedPoint.normalizedArcLength;

        const desaturatedCurve = SuperellipseMath.generateDesaturatedCurve(n, saturationPercent);
        const desaturatedPoint = SuperellipseMath.findPointAtArcLength(arcLength, desaturatedCurve);

        const newS = desaturatedPoint.x * 100;
        const newV = desaturatedPoint.y * 100;

        return this.hsvToHex(h, newS, newV);
      }

      /**
       * Parses RGB string format "rgb(r, g, b)"
       * @param {string} rgbString - RGB string
       * @returns {Object|null} RGB object {r, g, b} or null if invalid
       */
      static parseRgbString(rgbString) {
        const match = rgbString.match(/rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/);
        if (!match) return null;

        return {
          r: parseInt(match[1]),
          g: parseInt(match[2]),
          b: parseInt(match[3])
        };
      }

      /**
       * Determines optimal text color (black or white) for given background
       * @param {string} hexColor - Background HEX color
       * @returns {string} 'black' or 'white'
       */
      static getContrastTextColor(hexColor) {
        const { r, g, b } = this.hexToRgb(hexColor);
        const luminance = (0.250 * r + 0.350 * g + 0.150 * b) / 255;
        return luminance > 0.4 ? 'black' : 'white';
      }
    }

    // ============================================================================
    // SUPERELLIPSE MATHEMATICS MODULE
    // Handles superellipse curve calculations and point distribution
    // ============================================================================

    class SuperellipseMath {
      /**
       * Finds the exponent 'n' for superellipse equation: x^n + y^n = 1
       * Uses binary search to find n that passes through point (x, y)
       * @param {number} x - X coordinate (0-1)
       * @param {number} y - Y coordinate (0-1)
       * @returns {number} Exponent n for the superellipse
       */
      static findExponent(x, y) {
        const minThreshold = 0.001;
        const maxThreshold = 0.99;

        if (x <= minThreshold && y <= minThreshold) return CONFIG.SUPERELLIPSE_N_MIN;
        if (x <= minThreshold || y <= minThreshold) return CONFIG.SUPERELLIPSE_N_MIN;
        if (x >= maxThreshold && y >= maxThreshold) return CONFIG.SUPERELLIPSE_N_MAX;

        let nMin = CONFIG.SUPERELLIPSE_N_MIN;
        let nMax = CONFIG.SUPERELLIPSE_N_MAX;

        for (let i = 0; i < CONFIG.SUPERELLIPSE_MAX_ITERATIONS; i++) {
          const nMid = (nMin + nMax) / 2;
          const f = Math.pow(x, nMid) + Math.pow(y, nMid) - 1;

          if (Math.abs(f) < CONFIG.SUPERELLIPSE_TOLERANCE) {
            return Math.min(nMid, CONFIG.SUPERELLIPSE_N_MAX);
          }

          const fMin = Math.pow(x, nMin) + Math.pow(y, nMin) - 1;
          if (f * fMin < 0) nMax = nMid;
          else nMin = nMid;
        }

        return Math.min((nMin + nMax) / 2, CONFIG.SUPERELLIPSE_N_MAX);
      }

      /**
       * Generates points along the superellipse curve with arc length parameterization
       * @param {number} n - Superellipse exponent
       * @returns {Array} Array of curve points with positions and arc lengths
       */
      static generateCurvePoints(n) {
        const points = [];
        let totalArcLength = 0;
        const resolution = CONFIG.CURVE_RESOLUTION;
        const minSegmentLength = 1e-10;

        for (let i = 0; i <= resolution; i++) {
          const t = ((i / resolution) * Math.PI) / 2;

          try {
            const px = Math.pow(Math.cos(t), 2 / n);
            const py = Math.pow(Math.sin(t), 2 / n);

            const clampedX = Math.max(0, Math.min(1, px));
            const clampedY = Math.max(0, Math.min(1, py));

            const point = {
              t,
              x: clampedX,
              y: clampedY,
              pixelX: clampedX * CONFIG.PALETTE_SIZE,
              pixelY: (1 - clampedY) * CONFIG.PALETTE_SIZE,
              arcLength: totalArcLength
            };

            if (i > 0) {
              const prevPoint = points[i - 1];
              const dx = point.x - prevPoint.x;
              const dy = point.y - prevPoint.y;
              const segmentLength = Math.sqrt(dx * dx + dy * dy);

              if (segmentLength > minSegmentLength) {
                totalArcLength += segmentLength;
              }
              point.arcLength = totalArcLength;
            }

            points.push(point);
          } catch (e) {
            continue;
          }
        }

        if (totalArcLength > 0) {
          points.forEach(point => {
            point.normalizedArcLength = point.arcLength / totalArcLength;
          });
        } else {
          points.forEach((point, index) => {
            point.normalizedArcLength = index / (points.length - 1);
          });
        }

        return points;
      }

      /**
       * Generates points along a compressed (desaturated) superellipse curve.
       * The curve is compressed along the x-axis to create lower saturation values
       * while maintaining the same brightness distribution.
       * 
       * @param {number} nMain - Main superellipse exponent
       * @param {number} saturationPercent - Saturation percentage (0-100)
       * @returns {Array} Array of curve points for desaturated curve
       */
      static generateDesaturatedCurve(nMain, saturationPercent) {
        const points = [];
        const minCompressionFactor = 0.005;
        const minSegmentLength = 1e-10;

        const a = Math.max(minCompressionFactor, saturationPercent / 100);
        const nSecondary = 1 + (nMain - 1) * (saturationPercent / 100);

        let totalArcLength = 0;
        const resolution = CONFIG.CURVE_RESOLUTION;

        for (let i = 0; i <= resolution; i++) {
          const t = ((i / resolution) * Math.PI) / 2;

          try {
            const px = a * Math.pow(Math.cos(t), 2 / nSecondary);
            const py = Math.pow(Math.sin(t), 2 / nSecondary);

            const clampedX = Math.max(0, Math.min(1, px));
            const clampedY = Math.max(0, Math.min(1, py));

            const point = {
              t,
              x: clampedX,
              y: clampedY,
              pixelX: clampedX * CONFIG.PALETTE_SIZE,
              pixelY: (1 - clampedY) * CONFIG.PALETTE_SIZE,
              arcLength: totalArcLength
            };

            if (i > 0) {
              const prevPoint = points[i - 1];
              const dx = point.x - prevPoint.x;
              const dy = point.y - prevPoint.y;
              const segmentLength = Math.sqrt(dx * dx + dy * dy);

              if (segmentLength > minSegmentLength) {
                totalArcLength += segmentLength;
              }
              point.arcLength = totalArcLength;
            }

            points.push(point);
          } catch (e) {
            continue;
          }
        }

        if (totalArcLength > 0) {
          points.forEach(point => {
            point.normalizedArcLength = point.arcLength / totalArcLength;
          });
        } else {
          points.forEach((point, index) => {
            point.normalizedArcLength = index / (points.length - 1);
          });
        }

        return points;
      }

      /**
       * Finds the closest point on the curve to target coordinates using
       * optimized local search with line segment projection
       * 
       * @param {number} targetX - Target X coordinate
       * @param {number} targetY - Target Y coordinate
       * @param {Array} curvePoints - Array of curve points
       * @returns {Object} Closest point on the curve with arc length
       */
      static findClosestPoint(targetX, targetY, curvePoints) {
        const searchRadius = 3;
        const minSegmentLength = 1e-10;

        let closestPoint = curvePoints[0];
        let minDistance = Infinity;
        let closestIndex = 0;

        curvePoints.forEach((point, index) => {
          const dx = point.x - targetX;
          const dy = point.y - targetY;
          const distance = dx * dx + dy * dy;

          if (distance < minDistance) {
            minDistance = distance;
            closestPoint = point;
            closestIndex = index;
          }
        });

        const startIdx = Math.max(0, closestIndex - searchRadius);
        const endIdx = Math.min(curvePoints.length - 1, closestIndex + searchRadius);

        let bestPoint = closestPoint;
        let bestDistance = minDistance;

        for (let i = startIdx; i < endIdx; i++) {
          const p1 = curvePoints[i];
          const p2 = curvePoints[i + 1];

          const segmentVecX = p2.x - p1.x;
          const segmentVecY = p2.y - p1.y;
          const toTargetX = targetX - p1.x;
          const toTargetY = targetY - p1.y;

          const segmentLengthSq = segmentVecX * segmentVecX + segmentVecY * segmentVecY;

          if (segmentLengthSq > minSegmentLength) {
            const t = Math.max(0, Math.min(1,
              (toTargetX * segmentVecX + toTargetY * segmentVecY) / segmentLengthSq
            ));

            const projectedX = p1.x + t * segmentVecX;
            const projectedY = p1.y + t * segmentVecY;
            const projectedArcLength = p1.normalizedArcLength +
              t * (p2.normalizedArcLength - p1.normalizedArcLength);

            const dx = projectedX - targetX;
            const dy = projectedY - targetY;
            const distance = dx * dx + dy * dy;

            if (distance < bestDistance) {
              bestDistance = distance;
              bestPoint = {
                x: projectedX,
                y: projectedY,
                normalizedArcLength: projectedArcLength
              };
            }
          }
        }

        return bestPoint;
      }

      /**
       * Finds point at specific arc length position on curve using linear interpolation
       * @param {number} normalizedArcLength - Normalized arc length (0-1)
       * @param {Array} curvePoints - Array of curve points
       * @returns {Object} Point at specified arc length
       */
      static findPointAtArcLength(normalizedArcLength, curvePoints) {
        if (normalizedArcLength <= 0) return curvePoints[0];
        if (normalizedArcLength >= 1) return curvePoints[curvePoints.length - 1];

        for (let i = 1; i < curvePoints.length; i++) {
          const prevPoint = curvePoints[i - 1];
          const currPoint = curvePoints[i];

          if (normalizedArcLength >= prevPoint.normalizedArcLength &&
            normalizedArcLength <= currPoint.normalizedArcLength) {
            const t = (normalizedArcLength - prevPoint.normalizedArcLength) /
              (currPoint.normalizedArcLength - prevPoint.normalizedArcLength);

            return {
              x: prevPoint.x + t * (currPoint.x - prevPoint.x),
              y: prevPoint.y + t * (currPoint.y - prevPoint.y),
              normalizedArcLength
            };
          }
        }

        return curvePoints[curvePoints.length - 1];
      }
    }

    // ============================================================================
    // COLOR PALETTE GENERATOR
    // Generates distributed colors along the superellipse curve
    // ============================================================================

    class ColorGenerator {
      /**
       * Generates color palette distributed along superellipse curve.
       * Colors are calculated based on desaturated curve positions for consistent saturation control.
       * 
       * @param {Object} params - Generation parameters
       * @param {number} params.hue - Hue value (0-360)
       * @param {number} params.saturation - Saturation value (0-100)
       * @param {number} params.value - Brightness value (0-100)
       * @param {number} params.colorCount - Number of colors to generate
       * @param {number} params.contrast - Contrast distribution factor
       * @param {boolean} params.smartSpacing - Whether to use adaptive spacing
       * @param {boolean} params.includeBlackWhite - Whether to add black and white
       * @param {number} params.saturationControl - Global saturation control (0-100)
       * @returns {Object} Object containing colors array and curve points
       */
      static generatePalette(params) {
        const { hue, saturation, value, colorCount, contrast, smartSpacing, includeBlackWhite, saturationControl } = params;

        const normalizedX = saturation / 100;
        const normalizedY = value / 100;

        const n = SuperellipseMath.findExponent(normalizedX, normalizedY);
        const curvePoints = SuperellipseMath.generateCurvePoints(n);

        const selectedPoint = SuperellipseMath.findClosestPoint(normalizedX, normalizedY, curvePoints);
        const selectedArcLength = selectedPoint.normalizedArcLength;

        const colors = [];
        const count = parseInt(colorCount);
        const pointsToDistribute = count - 1;

        const useContrastMode = contrast !== 1.0;
        let pointsBefore, pointsAfter;

        if (smartSpacing && !useContrastMode) {
          pointsBefore = Math.round(selectedArcLength * pointsToDistribute);
          pointsAfter = pointsToDistribute - pointsBefore;

          if (pointsBefore === 0 && pointsAfter > 1) {
            pointsBefore = 1;
            pointsAfter = pointsAfter - 1;
          } else if (pointsAfter === 0 && pointsBefore > 1) {
            pointsAfter = 1;
            pointsBefore = pointsBefore - 1;
          }
        } else {
          if (count % 2 === 0) {
            const smallerSegment = Math.floor(pointsToDistribute / 2);
            const largerSegment = Math.ceil(pointsToDistribute / 2);

            const beforeLength = selectedArcLength;
            const afterLength = 1 - selectedArcLength;

            if (beforeLength >= afterLength) {
              pointsBefore = largerSegment;
              pointsAfter = smallerSegment;
            } else {
              pointsBefore = smallerSegment;
              pointsAfter = largerSegment;
            }
          } else {
            pointsBefore = pointsToDistribute / 2;
            pointsAfter = pointsToDistribute / 2;
          }
        }

        const saturationPercent = saturationControl !== undefined ? saturationControl : CONFIG.SATURATION_DEFAULT;
        const desaturatedCurvePoints = SuperellipseMath.generateDesaturatedCurve(n, saturationPercent);

        for (let i = 0; i < pointsBefore; i++) {
          const arcLength = this._calculateArcLength(
            i, pointsBefore, selectedArcLength, contrast, useContrastMode, true
          );

          const mainPoint = SuperellipseMath.findPointAtArcLength(arcLength, curvePoints);
          const mainS = mainPoint.x * 100;
          const mainV = mainPoint.y * 100;
          const mainHex = ColorMath.hsvToHex(hue, mainS, mainV);

          const desaturatedPoint = SuperellipseMath.findPointAtArcLength(arcLength, desaturatedCurvePoints);
          const s = desaturatedPoint.x * 100;
          const v = desaturatedPoint.y * 100;
          const hex = ColorMath.hsvToHex(hue, s, v);

          colors.push({
            hex,
            s,
            v,
            arcLength,
            mainS,
            mainV,
            mainHex
          });
        }

        const selectedDesaturatedPoint = SuperellipseMath.findPointAtArcLength(selectedArcLength, desaturatedCurvePoints);
        const selectedS = selectedDesaturatedPoint.x * 100;
        const selectedV = selectedDesaturatedPoint.y * 100;
        const selectedMainHex = ColorMath.hsvToHex(hue, saturation, value);

        colors.push({
          hex: ColorMath.hsvToHex(hue, selectedS, selectedV),
          s: selectedS,
          v: selectedV,
          arcLength: selectedArcLength,
          isSelected: true,
          mainS: saturation,
          mainV: value,
          mainHex: selectedMainHex
        });

        for (let i = 0; i < pointsAfter; i++) {
          const arcLength = this._calculateArcLength(
            i, pointsAfter, selectedArcLength, contrast, useContrastMode, false
          );

          const mainPoint = SuperellipseMath.findPointAtArcLength(arcLength, curvePoints);
          const mainS = mainPoint.x * 100;
          const mainV = mainPoint.y * 100;
          const mainHex = ColorMath.hsvToHex(hue, mainS, mainV);

          const desaturatedPoint = SuperellipseMath.findPointAtArcLength(arcLength, desaturatedCurvePoints);
          const s = desaturatedPoint.x * 100;
          const v = desaturatedPoint.y * 100;
          const hex = ColorMath.hsvToHex(hue, s, v);

          colors.push({
            hex,
            s,
            v,
            arcLength,
            mainS,
            mainV,
            mainHex
          });
        }

        if (includeBlackWhite) {
          colors.unshift({
            hex: '#000000',
            s: 0,
            v: 0,
            arcLength: 0,
            isBlack: true,
            mainS: 0,
            mainV: 0,
            mainHex: '#000000'
          });
          colors.push({
            hex: '#FFFFFF',
            s: 0,
            v: 100,
            arcLength: 1,
            isWhite: true,
            mainS: 0,
            mainV: 100,
            mainHex: '#FFFFFF'
          });
        }

        return { colors, curvePoints, desaturatedCurvePoints };
      }

      /**
       * Calculates arc length position with optional contrast-based distribution.
       * Applies power function for non-linear spacing when contrast is enabled.
       * 
       * @param {number} index - Current index in the distribution
       * @param {number} total - Total number of points to distribute
       * @param {number} selectedArc - Arc length of selected point
       * @param {number} contrast - Contrast factor
       * @param {boolean} useContrast - Whether to apply contrast distribution
       * @param {boolean} isBefore - Whether point is before or after selected point
       * @returns {number} Calculated arc length position
       * @private
       */
      static _calculateArcLength(index, total, selectedArc, contrast, useContrast, isBefore) {
        if (!useContrast) {
          if (isBefore) {
            return (selectedArc / (total + 1)) * (index + 1);
          } else {
            return selectedArc + ((1 - selectedArc) / (total + 1)) * (index + 1);
          }
        }

        const normalizedDistance = (isBefore ? (total - index) : (index + 1)) / (total + 1);
        let poweredDistance;

        const contrastHighThreshold = 1.0;
        const contrastLowThreshold = 1.0;
        const contrastHighExponent = 1.5;
        const contrastLowExponent = 1.5;
        const maxContrastRange = 4.0;
        const minContrastRange = 0.9;

        if (contrast > contrastHighThreshold) {
          const t = Math.min((contrast - contrastHighThreshold) / maxContrastRange, 1.0);
          const linear = normalizedDistance;
          const curved = Math.pow(normalizedDistance, 1 / contrastHighExponent);
          poweredDistance = linear * (1 - t) + curved * t;
        } else if (contrast < contrastLowThreshold) {
          const t = Math.min((contrastLowThreshold - contrast) / minContrastRange, 1.0);
          const linear = normalizedDistance;
          const curved = Math.pow(normalizedDistance, contrastLowExponent);
          poweredDistance = linear * (1 - t) + curved * t;
        } else {
          poweredDistance = normalizedDistance;
        }

        if (isBefore) {
          return selectedArc - selectedArc * poweredDistance;
        } else {
          return selectedArc + (1 - selectedArc) * poweredDistance;
        }
      }

      /**
       * Generates display names for colors based on their position in the palette
       * @param {Array} colors - Array of color objects
       * @param {string} baseName - Base name for the palette
       * @returns {Array} Colors with display names
       */
      static generateColorNames(colors, baseName) {
        const mainColors = colors.filter(c => !c.isBlack && !c.isWhite);
        const totalMainColors = mainColors.length;
        const nameMultiplier = 10;

        let colorCounter = 0;
        return colors.map(color => {
          let displayName;

          if (color.isBlack) {
            displayName = 'Black';
          } else if (color.isWhite) {
            displayName = 'White';
          } else {
            const index = (totalMainColors - colorCounter) * nameMultiplier;
            displayName = `${baseName} ${index}`;
            colorCounter++;
          }

          return { ...color, displayName };
        });
      }
    }

    // ============================================================================
    // APPLICATION STATE MANAGER
    // Central state management for the application
    // ============================================================================

    class AppState {
      constructor() {
        this.hue = 220;
        this.saturation = 81;
        this.value = 78;
        this.saturationControl = CONFIG.SATURATION_DEFAULT;

        this.colorCount = 10;
        this.contrast = 1.0;
        this.colorName = '';

        this.features = {
          importWithVariables: true,
          reverseOrder: false,
          includeBlackWhite: false,
          smartSpacing: false,
          rgbFormat: false
        };

        this.generatedColors = [];
        this.curvePoints = [];

        this.isDragging = false;
        this.activeTab = 'result';

        this.observers = new Set();
      }

      /**
       * Subscribe to state changes
       * @param {Function} callback - Function to call on state change
       */
      subscribe(callback) {
        this.observers.add(callback);
      }

      /**
       * Unsubscribe from state changes
       * @param {Function} callback - Callback to remove
       */
      unsubscribe(callback) {
        this.observers.delete(callback);
      }

      /**
       * Notify all observers of state change
       * @param {string} changeType - Type of change that occurred
       * @private
       */
      _notify(changeType) {
        this.observers.forEach(callback => callback(changeType, this));
      }

      /**
       * Update HSV color values
       * @param {number} h - Hue (0-360)
       * @param {number} s - Saturation (0-100)
       * @param {number} v - Value (0-100)
       */
      updateColor(h, s, v) {
        this.hue = h;
        this.saturation = s;
        this.value = v;
        this._notify('color');
      }

      /**
       * Update generation settings
       * @param {Object} settings - Settings to update
       */
      updateSettings(settings) {
        Object.assign(this, settings);
        this._notify('settings');
      }

      /**
       * Toggle a feature on/off
       * @param {string} featureName - Name of feature to toggle
       */
      toggleFeature(featureName) {
        if (featureName in this.features) {
          this.features[featureName] = !this.features[featureName];
          this._notify('feature');
        }
      }

      /**
       * Set a feature to specific state
       * @param {string} featureName - Name of feature
       * @param {boolean} value - New state
       */
      setFeature(featureName, value) {
        if (featureName in this.features) {
          this.features[featureName] = value;
          this._notify('feature');
        }
      }

      /**
       * Update generated colors and curve data
       * @param {Array} colors - Generated color array
       * @param {Array} curvePoints - Curve points array
       */
      updateGeneratedColors(colors, curvePoints) {
        this.generatedColors = colors;
        this.curvePoints = curvePoints;
        this._notify('colors');
      }

      /**
       * Get current color in HEX format
       * @returns {string} HEX color string
       */
      getCurrentHex() {
        return ColorMath.hsvToHex(this.hue, this.saturation, this.value);
      }

      /**
       * Get current color in RGB format
       * @returns {Object} RGB object {r, g, b}
       */
      getCurrentRgb() {
        const hex = this.getCurrentHex();
        return ColorMath.hexToRgb(hex);
      }

      /**
       * Apply preset configuration to current state
       * @param {Object} presetConfig - Preset configuration object
       */
      applyPreset(presetConfig) {
        const hsv = ColorMath.hexToHsv(presetConfig.color);
        this.updateColor(hsv.h, hsv.s, hsv.v);
        this.contrast = presetConfig.contrast;
        this.colorName = presetConfig.name;
        this.saturationControl = presetConfig.saturation !== undefined ? presetConfig.saturation : CONFIG.SATURATION_DEFAULT;

        if (this.features.smartSpacing) {
          this.setFeature('smartSpacing', false);
        }

        this._notify('preset');
      }
    }

    // ============================================================================
    // COLOR PICKER CONTROLLER
    // Manages interactive color picker UI
    // ============================================================================

    class ColorPickerController {
      constructor(state, elements) {
        this.state = state;
        this.elements = elements;
        this.isDragging = false;

        this._initializeEventListeners();
      }

      /**
       * Initialize all event listeners for color picker
       * @private
       */
      _initializeEventListeners() {
        this._initializeHueSlider();
        this._initializeColorPalette();
        this._initializeSaturationSlider();
      }

      /**
       * Initialize hue slider interaction
       * @private
       */
      _initializeHueSlider() {
        this.elements.hueSlider.addEventListener('mousedown', (e) => {
          e.preventDefault();
          this.isDragging = true;
          this._updateHue(e);

          const onMove = (e) => this.isDragging && this._updateHue(e);
          const onUp = () => {
            this.isDragging = false;
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
          };

          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', onUp);
        });
      }

      /**
       * Initialize color palette interaction
       * @private
       */
      _initializeColorPalette() {
        this.elements.colorPalette.addEventListener('mousedown', (e) => {
          e.preventDefault();
          this.isDragging = true;
          this._updateSaturationValue(e);

          const onMove = (e) => this.isDragging && this._updateSaturationValue(e);
          const onUp = () => {
            this.isDragging = false;
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
          };

          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', onUp);
        });
      }

      /**
       * Initialize saturation slider interaction
       * @private
       */
      _initializeSaturationSlider() {
        if (!this.elements.saturationSlider) return;

        this.elements.saturationSlider.addEventListener('mousedown', (e) => {
          e.preventDefault();
          this.isDragging = true;
          this._updateSaturationControl(e);

          const onMove = (e) => this.isDragging && this._updateSaturationControl(e);
          const onUp = () => {
            this.isDragging = false;
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
          };

          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', onUp);
        });
      }

      /**
       * Update hue based on mouse position
       * @param {MouseEvent} e - Mouse event
       * @private
       */
      _updateHue(e) {
        const rect = this.elements.hueSlider.getBoundingClientRect();
        const y = Math.max(0, Math.min(rect.height, e.clientY - rect.top));
        const hue = (y / rect.height) * 360;

        this.state.updateColor(hue, this.state.saturation, this.state.value);
      }

      /**
       * Update saturation and value based on mouse position
       * @param {MouseEvent} e - Mouse event
       * @private
       */
      _updateSaturationValue(e) {
        const rect = this.elements.colorPalette.getBoundingClientRect();
        const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
        const y = Math.max(0, Math.min(rect.height, e.clientY - rect.top));

        const saturation = (x / rect.width) * 100;
        const value = 100 - (y / rect.height) * 100;

        this.state.updateColor(this.state.hue, saturation, value);
      }

      /**
       * Update saturation control based on mouse position
       * @param {MouseEvent} e - Mouse event
       * @private
       */
      _updateSaturationControl(e) {
        if (!this.elements.saturationSlider) return;

        const rect = this.elements.saturationSlider.getBoundingClientRect();
        const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
        const saturationControl = (x / rect.width) * 100;

        this.state.saturationControl = saturationControl;
        this.updateSaturationSlider();
        this.drawDesaturatedCurve();
        this.drawDesaturatedDistributionPoints();
        this.state._notify('saturation-control');
      }

      /**
       * Update visual representation of color picker
       */
      updateVisuals() {
        const { hue, saturation, value } = this.state;
        const hex = this.state.getCurrentHex();

        this.elements.colorPalette.style.background =
          `linear-gradient(to right, white, hsl(${hue}, 100%, 50%))`;

        this.elements.colorPreview.style.background = hex;
        this.elements.colorHandle.style.background = hex;

        this.elements.colorHandle.style.left = (saturation / 100) * CONFIG.PALETTE_SIZE + 'px';
        this.elements.colorHandle.style.top = ((100 - value) / 100) * CONFIG.PALETTE_SIZE + 'px';
        this.elements.hueHandle.style.top = (hue / 360) * CONFIG.HUE_SLIDER_SIZE - 4.5 + 'px';
        
        this.updateSaturationSlider();
        this.drawCurve();
        this.drawDesaturatedCurve();
      }

      /**
       * Draw primary superellipse curve on color palette
       */
      drawCurve() {
        const x = this.state.saturation / 100;
        const y = this.state.value / 100;
        const n = SuperellipseMath.findExponent(x, y);

        let svg = this.elements.colorPalette.querySelector('.superellipse-curve');
        if (!svg) {
          svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svg.classList.add('superellipse-curve');
          this.elements.colorPalette.appendChild(svg);
        }

        svg.innerHTML = '';

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const points = [];
        const curveResolution = 100;

        for (let i = 0; i <= curveResolution; i++) {
          const t = ((i / curveResolution) * Math.PI) / 2;

          try {
            const px = Math.pow(Math.cos(t), 2 / n);
            const py = Math.pow(Math.sin(t), 2 / n);

            const pixelX = px * CONFIG.PALETTE_SIZE;
            const pixelY = (1 - py) * CONFIG.PALETTE_SIZE;

            points.push([pixelX, pixelY]);
          } catch (e) {
            continue;
          }
        }

        if (points.length > 0) {
          let pathData = `M ${points[0][0]} ${points[0][1]}`;
          for (let i = 1; i < points.length; i++) {
            pathData += ` L ${points[i][0]} ${points[i][1]}`;
          }

          path.setAttribute('d', pathData);
          path.setAttribute('stroke', `rgba(255, 255, 255, ${CONFIG.CURVE_PRIMARY_OPACITY})`);
          path.setAttribute('stroke-width', CONFIG.CURVE_STROKE_WIDTH.toString());
          path.setAttribute('fill', 'none');

          svg.appendChild(path);
        }
      }

      /**
       * Draw desaturated (secondary) superellipse curve on color palette
       */
      drawDesaturatedCurve() {
        const x = this.state.saturation / 100;
        const y = this.state.value / 100;
        const nMain = SuperellipseMath.findExponent(x, y);
        const saturationPercent = this.state.saturationControl;

        const curvePoints = SuperellipseMath.generateDesaturatedCurve(nMain, saturationPercent);

        let svg = this.elements.colorPalette.querySelector('.desaturated-curve');
        if (!svg) {
          svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svg.classList.add('desaturated-curve');
          this.elements.colorPalette.appendChild(svg);
        }

        svg.innerHTML = '';

        if (saturationPercent < CONFIG.SATURATION_MIN_THRESHOLD || curvePoints.length < 2) {
          return;
        }

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

        let pathData = `M ${curvePoints[0].pixelX} ${curvePoints[0].pixelY}`;
        for (let i = 1; i < curvePoints.length; i++) {
          pathData += ` L ${curvePoints[i].pixelX} ${curvePoints[i].pixelY}`;
        }

        path.setAttribute('d', pathData);
        path.setAttribute('stroke', `rgba(255, 255, 255, ${CONFIG.CURVE_SECONDARY_OPACITY})`);
        path.setAttribute('stroke-width', CONFIG.CURVE_STROKE_WIDTH.toString());
        path.setAttribute('fill', 'none');
        svg.appendChild(path);
      }

      /**
       * Draw distribution points on the main curve
       */
      drawDistributionPoints() {
        const existingPoints = this.elements.colorPalette.querySelectorAll('.distribution-point');
        existingPoints.forEach(point => point.remove());

        this.state.generatedColors.forEach(color => {
          if (!color.isSelected && !color.isBlack && !color.isWhite) {
            const point = document.createElement('div');
            point.className = 'distribution-point';

            const posS = color.mainS !== undefined ? color.mainS : color.s;
            const posV = color.mainV !== undefined ? color.mainV : color.v;
            point.style.left = (posS / 100) * CONFIG.PALETTE_SIZE + 'px';
            point.style.top = ((100 - posV) / 100) * CONFIG.PALETTE_SIZE + 'px';

            const pointColor = color.mainHex !== undefined ? color.mainHex : color.hex;
            point.style.background = pointColor;

            this.elements.colorPalette.appendChild(point);
          }
        });

        this.drawDesaturatedDistributionPoints();
      }

      /**
       * Draw distribution points on the desaturated curve
       */
      drawDesaturatedDistributionPoints() {
        const existingPoints = this.elements.colorPalette.querySelectorAll('.distribution-point-secondary');
        existingPoints.forEach(point => point.remove());

        const saturationPercent = this.state.saturationControl;

        if (saturationPercent < CONFIG.SATURATION_MIN_THRESHOLD) {
          return;
        }

        const x = this.state.saturation / 100;
        const y = this.state.value / 100;
        const nMain = SuperellipseMath.findExponent(x, y);
        const desaturatedCurvePoints = SuperellipseMath.generateDesaturatedCurve(nMain, saturationPercent);

        if (desaturatedCurvePoints.length < 2) {
          return;
        }

        this.state.generatedColors.forEach(color => {
          if (color.isBlack || color.isWhite) {
            return;
          }

          const targetArcLength = color.arcLength;
          const projectedPoint = SuperellipseMath.findPointAtArcLength(targetArcLength, desaturatedCurvePoints);

          if (!projectedPoint) {
            return;
          }

          const point = document.createElement('div');
          point.className = 'distribution-point-secondary';
          point.style.left = projectedPoint.x * CONFIG.PALETTE_SIZE + 'px';
          point.style.top = (1 - projectedPoint.y) * CONFIG.PALETTE_SIZE + 'px';
          point.style.background = color.hex;

          this.elements.colorPalette.appendChild(point);
        });
      }

      /**
       * Update saturation slider gradient and handle position
       */
      updateSaturationSlider() {
        const { hue, value } = this.state;
        const saturationControl = this.state.saturationControl;

        const grayColor = ColorMath.hsvToHex(hue, 0, value);
        const fullSatColor = ColorMath.hsvToHex(hue, 100, value);

        if (this.elements.saturationSlider) {
          this.elements.saturationSlider.style.background =
            `linear-gradient(90deg, ${grayColor} 0%, ${fullSatColor} 100%)`;
        }

        if (this.elements.saturationHandle) {
          this.elements.saturationHandle.style.left = `${saturationControl}%`;
        }

        if (this.elements.saturationValueDisplay) {
          this.elements.saturationValueDisplay.textContent = Math.round(saturationControl);
        }
      }
    }

    // ============================================================================
    // UI CONTROLLER
    // Main UI management and coordination
    // ============================================================================

    class UIController {
      constructor(state) {
        this.state = state;
        this.elements = this._gatherElements();
        this.colorPicker = new ColorPickerController(state, {
          hueSlider: this.elements.hueSlider,
          hueHandle: this.elements.hueHandle,
          colorPalette: this.elements.colorPalette,
          colorHandle: this.elements.colorHandle,
          colorPreview: this.elements.colorPreview,
          saturationSlider: this.elements.saturationSlider,
          saturationHandle: this.elements.saturationHandle,
          saturationValueDisplay: this.elements.saturationValueDisplay
        });

        this._initializeEventListeners();
        this._initializeTooltips();
        this._initializeDragControls();

        this.state.subscribe((changeType) => this._handleStateChange(changeType));
      }

      /**
       * Gather all DOM elements
       * @returns {Object} Object containing all DOM element references
       * @private
       */
      _gatherElements() {
        return {
          colorName: document.getElementById('colorName'),
          colorValue: document.getElementById('colorValue'),
          colorPreview: document.getElementById('colorPreview'),
          colorPrefix: document.getElementById('colorPrefix'),
          colorSuffix: document.getElementById('colorSuffix'),
          contrastInput: document.getElementById('contrastInput'),
          colorCount: document.getElementById('colorCount'),
          colorsList: document.getElementById('colorsList'),
          presetsList: document.getElementById('presetsList'),
          importButton: document.getElementById('importButton'),
          hueSlider: document.getElementById('hueSlider'),
          hueHandle: document.getElementById('hueHandle'),
          colorPalette: document.getElementById('colorPalette'),
          colorHandle: document.getElementById('colorHandle'),
          customTooltip: document.getElementById('customTooltip'),
          errorTooltip: document.getElementById('errorTooltip'),
          toggleSlide: document.getElementById('toggleSlide'),
          saturationSlider: document.getElementById('saturationSlider'),
          saturationHandle: document.getElementById('saturationHandle'),
          saturationValueDisplay: document.getElementById('saturationValueDisplay')
        };
      }

      /**
       * Initialize all UI event listeners
       * @private
       */
      _initializeEventListeners() {
        this._initializeFeatureToggles();
        this._initializeColorInputs();
        this._initializeNumericInputs();
        this._initializeTabSwitching();
        this._initializeImportButton();
        this._initializeInputValidation();
      }

      /**
       * Initialize feature toggle buttons
       * @private
       */
      _initializeFeatureToggles() {
        document.querySelectorAll('.feature-toggle').forEach(toggle => {
          toggle.addEventListener('click', () => {
            const feature = toggle.dataset.feature;
            this._handleFeatureToggle(feature, toggle);
          });
        });
      }

      /**
       * Initialize color input fields
       * @private
       */
      _initializeColorInputs() {
        this.elements.colorValue.addEventListener('input', (e) => {
          this._handleColorInput(e.target.value);
        });

        this.elements.colorName.addEventListener('input', (e) => {
          this.state.colorName = e.target.value.trim();
          this.elements.importButton.disabled = !this.state.colorName;
          this._updateColorsList();
        });
      }

      /**
       * Initialize numeric input fields
       * @private
       */
      _initializeNumericInputs() {
        this.elements.colorCount.addEventListener('input', (e) => {
          const value = Math.max(CONFIG.COLOR_COUNT_MIN,
            Math.min(CONFIG.COLOR_COUNT_MAX, parseInt(e.target.value) || 10));
          this.state.updateSettings({ colorCount: value });
          this._regenerateColors();
        });

        this.elements.contrastInput.addEventListener('input', (e) => {
          const value = Math.max(CONFIG.CONTRAST_MIN,
            Math.min(CONFIG.CONTRAST_MAX, parseFloat(e.target.value) || 1.0));

          this.state.updateSettings({ contrast: value });

          if (value !== 1.0 && this.state.features.smartSpacing) {
            this._toggleFeatureButton('smartSpacing', false);
          }

          this._regenerateColors();
        });
      }

      /**
       * Initialize tab switching functionality
       * @private
       */
      _initializeTabSwitching() {
        document.querySelectorAll('.toggle-button').forEach(button => {
          button.addEventListener('click', () => {
            this._switchTab(button.dataset.tab);
          });
        });
      }

      /**
       * Initialize import button
       * @private
       */
      _initializeImportButton() {
        this.elements.importButton.addEventListener('click', () => {
          this._exportToFigma();
        });
      }

      /**
       * Handle feature toggle clicks
       * @param {string} feature - Feature name
       * @param {HTMLElement} toggleElement - Toggle button element
       * @private
       */
      _handleFeatureToggle(feature, toggleElement) {
        toggleElement.classList.toggle('active');
        const isActive = toggleElement.classList.contains('active');

        switch (feature) {
          case 'variables':
            this.state.setFeature('importWithVariables', isActive);
            break;

          case 'reverse':
            this.state.setFeature('reverseOrder', isActive);
            this._updateColorsList();
            break;

          case 'blackwhite':
            this.state.setFeature('includeBlackWhite', isActive);
            this._regenerateColors();
            break;

          case 'smartSpacing':
            this.state.setFeature('smartSpacing', isActive);

            const contrastContainer = this.elements.contrastInput.closest('.contrast-input');
            if (isActive) {
              this.state.contrast = 1.0;
              this.elements.contrastInput.value = '1.0';
              this.elements.contrastInput.disabled = true;
              contrastContainer.classList.add('disabled');
            } else {
              this.elements.contrastInput.disabled = false;
              contrastContainer.classList.remove('disabled');
            }

            this._updateDragControlsState();
            this._regenerateColors();
            break;

          case 'rgb':
            this.state.setFeature('rgbFormat', isActive);
            this._updateColorDisplay();
            this._updateColorsList();
            break;
        }
      }

      /**
       * Handle color input changes
       * @param {string} value - Input value
       * @private
       */
      _handleColorInput(value) {
        const parsed = this._parseColorInput(value);
        if (!parsed) return;

        if (this.state.features.rgbFormat) {
          const rgb = ColorMath.parseRgbString(parsed);
          if (rgb) {
            const hsv = ColorMath.rgbToHsv(rgb.r, rgb.g, rgb.b);
            this.state.updateColor(hsv.h, hsv.s, hsv.v);
          }
        } else {
          const hsv = ColorMath.hexToHsv(parsed);
          this.state.updateColor(hsv.h, hsv.s, hsv.v);
        }
      }

      /**
       * Parse color input string to HEX or RGB
       * @param {string} input - Raw input string
       * @returns {string|null} Parsed color string or null
       * @private
       */
      _parseColorInput(input) {
        const value = input.trim();

        if (!this.state.features.rgbFormat) {
          const hexValue = value.replace(/^#/, '');
          if (hexValue.match(/^[0-9A-F]{6}$/i)) {
            return '#' + hexValue.toUpperCase();
          }
        } else {
          const numbers = value.replace(/[^\d\s,\.]/g, '').split(/[\s,\.]+/).filter(n => n);
          if (numbers.length >= 3) {
            const r = Math.min(255, Math.max(0, parseInt(numbers[0]) || 0));
            const g = Math.min(255, Math.max(0, parseInt(numbers[1]) || 0));
            const b = Math.min(255, Math.max(0, parseInt(numbers[2]) || 0));
            return `rgb(${r}, ${g}, ${b})`;
          }
        }

        return null;
      }

      /**
       * Handle state changes from AppState
       * @param {string} changeType - Type of change
       * @private
       */
      _handleStateChange(changeType) {
        switch (changeType) {
          case 'color':
            this.colorPicker.updateVisuals();
            this.colorPicker.drawCurve();
            if (document.activeElement !== this.elements.colorValue) {
              this._updateColorDisplay();
            }
            this._regenerateColors();
            break;

          case 'settings':
          case 'feature':
            this._regenerateColors();
            break;

          case 'colors':
            this.colorPicker.drawDistributionPoints();
            this.colorPicker.drawDesaturatedDistributionPoints();
            this._updateColorsList();
            break;

          case 'saturation-control':
            this._regenerateColors();
            break;

          case 'preset':
            this.elements.colorName.value = this.state.colorName;
            this.elements.contrastInput.value = this.state.contrast;
            this.elements.importButton.disabled = false;

            const contrastContainer = this.elements.contrastInput.closest('.contrast-input');
            this.elements.contrastInput.disabled = false;
            contrastContainer.classList.remove('disabled');

            this.colorPicker.updateSaturationSlider();
            this.colorPicker.drawDesaturatedCurve();
            this._updateDragControlsState();
            this._regenerateColors();
            break;
        }
      }

      /**
       * Regenerate color palette
       * @private
       */
      _regenerateColors() {
        const { colors, curvePoints } = ColorGenerator.generatePalette({
          hue: this.state.hue,
          saturation: this.state.saturation,
          value: this.state.value,
          colorCount: this.state.colorCount,
          contrast: this.state.contrast,
          smartSpacing: this.state.features.smartSpacing,
          includeBlackWhite: this.state.features.includeBlackWhite,
          saturationControl: this.state.saturationControl
        });

        this.state.updateGeneratedColors(colors, curvePoints);
      }

      /**
       * Update color display in input field
       * @private
       */
      _updateColorDisplay() {
        const hex = this.state.getCurrentHex();

        if (!this.state.features.rgbFormat) {
          this.elements.colorPrefix.textContent = '#';
          this.elements.colorSuffix.textContent = '';
          this.elements.colorValue.value = hex.substring(1);
        } else {
          const rgb = this.state.getCurrentRgb();
          this.elements.colorPrefix.textContent = 'rgb(';
          this.elements.colorSuffix.textContent = ')';
          this.elements.colorValue.value = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
        }
      }

      /**
       * Update colors list display
       * @private
       */
      _updateColorsList() {
        this.elements.colorsList.innerHTML = '';

        const baseName = this.state.colorName || 'Color';
        const namedColors = ColorGenerator.generateColorNames(this.state.generatedColors, baseName);

        let colorsToShow = [...namedColors];
        if (!this.state.features.reverseOrder) {
          colorsToShow.reverse();
        }

        colorsToShow.forEach(color => {
          const item = document.createElement('div');
          item.className = 'color-preview-item';
          if (color.isSelected) item.classList.add('selected');

          let displayValue = color.hex;
          if (this.state.features.rgbFormat) {
            const rgb = ColorMath.hexToRgb(color.hex);
            displayValue = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
          }

          const textColor = ColorMath.getContrastTextColor(color.hex);

          item.innerHTML = `
            <span class="color-name" style="color:${textColor}">${color.displayName}</span>
            <span class="color-hex" style="color:${textColor}">${displayValue}</span>
          `;
          item.style.backgroundColor = color.hex;

          this.elements.colorsList.appendChild(item);
        });
      }

      /**
       * Switch between tabs (Result/Presets)
       * @param {string} tab - Tab name ('result' or 'presets')
       * @private
       */
      _switchTab(tab) {
        const slide = this.elements.toggleSlide;
        const resultBtn = document.querySelector('.result-button');
        const presetsBtn = document.querySelector('.resources-button');
        const colorsList = this.elements.colorsList;
        const presetsList = this.elements.presetsList;
        const slideOffset = 102;

        if (tab === 'result') {
          slide.style.transform = 'translateX(0)';
          resultBtn.classList.add('active');
          presetsBtn.classList.remove('active');

          presetsList.style.opacity = '0';
          setTimeout(() => {
            presetsList.style.display = 'none';
            colorsList.style.display = 'flex';
            colorsList.style.opacity = '0';
            setTimeout(() => colorsList.style.opacity = '1', 10);
          }, CONFIG.TAB_TRANSITION_DELAY);
        } else {
          slide.style.transform = `translateX(${slideOffset}px)`;
          resultBtn.classList.remove('active');
          presetsBtn.classList.add('active');

          colorsList.style.opacity = '0';
          setTimeout(() => {
            colorsList.style.display = 'none';
            presetsList.style.display = 'flex';
            presetsList.style.opacity = '0';
            setTimeout(() => presetsList.style.opacity = '1', 10);
          }, CONFIG.TAB_TRANSITION_DELAY);
        }

        this.state.activeTab = tab;
      }

      /**
       * Export palette to Figma
       * @private
       */
      _exportToFigma() {
        const baseName = this.state.colorName.trim() || 'Color';
        const namedColors = ColorGenerator.generateColorNames(this.state.generatedColors, baseName);

        let colorsToExport = [...namedColors];
        if (!this.state.features.reverseOrder) {
          colorsToExport.reverse();
        }

        const rgbDivisor = 255;
        const exportData = colorsToExport.map(color => {
          const rgb = ColorMath.hexToRgb(color.hex);
          const textColor = ColorMath.getContrastTextColor(color.hex);

          return {
            hex: color.hex,
            name: color.displayName,
            rgb: {
              r: rgb.r / rgbDivisor,
              g: rgb.g / rgbDivisor,
              b: rgb.b / rgbDivisor
            },
            textColor: textColor === 'white'
              ? { r: 1, g: 1, b: 1 }
              : { r: 0, g: 0, b: 0 },
            rgbString: `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`,
            isSelected: color.isSelected || false,
            isBlack: color.isBlack || false,
            isWhite: color.isWhite || false
          };
        });

        parent.postMessage({
          pluginMessage: {
            type: 'create-palette',
            colors: exportData,
            paletteName: baseName,
            isRgbFormat: this.state.features.rgbFormat,
            withVariables: this.state.features.importWithVariables
          }
        }, '*');
      }

      /**
       * Initialize tooltips for feature toggles
       * @private
       */
      _initializeTooltips() {
        const tooltip = this.elements.customTooltip;
        const toggles = document.querySelectorAll('.feature-toggle');
        const tooltipOffsetX = 18;
        const tooltipOffsetY = 152;

        let tooltipTimeout = null;

        toggles.forEach(toggle => {
          const feature = toggle.dataset.feature;
          const text = FEATURE_TOOLTIPS[feature];

          if (!text) return;

          toggle.addEventListener('mouseenter', (e) => {
            if (tooltipTimeout) clearTimeout(tooltipTimeout);

            tooltipTimeout = setTimeout(() => {
              tooltip.innerHTML = text;
              tooltip.classList.add('show');

              const buttonRect = toggle.getBoundingClientRect();
              const containerRect = toggle.closest('.feature-toggles').getBoundingClientRect();

              const left = buttonRect.left - containerRect.left + (buttonRect.width / 2) + tooltipOffsetX;
              const top = buttonRect.bottom - containerRect.top + tooltipOffsetY;

              tooltip.style.left = left + 'px';
              tooltip.style.top = top + 'px';
              tooltip.style.transform = 'translateX(-50%) translateY(0)';
            }, CONFIG.TOOLTIP_DELAY);
          });

          toggle.addEventListener('mouseleave', () => {
            if (tooltipTimeout) {
              clearTimeout(tooltipTimeout);
              tooltipTimeout = null;
            }
            tooltip.classList.remove('show');
          });
        });

        this._initializeErrorTooltip();
      }

      /**
       * Initialize error tooltip for disabled import button
       * @private
       */
      _initializeErrorTooltip() {
        const errorTooltip = this.elements.errorTooltip;
        const importButton = this.elements.importButton;
        const settingsContainer = document.querySelector('.settings');
        const tooltipOffsetX = 20;
        const tooltipOffsetY = 88;

        let errorTimeout = null;

        importButton.addEventListener('mouseenter', () => {
          if (!importButton.disabled) return;

          if (errorTimeout) clearTimeout(errorTimeout);

          errorTimeout = setTimeout(() => {
            errorTooltip.innerHTML = 'Enter color name first';

            const buttonRect = importButton.getBoundingClientRect();
            const settingsRect = settingsContainer.getBoundingClientRect();

            const left = buttonRect.left - settingsRect.left + (buttonRect.width / 2) + tooltipOffsetX;
            const top = buttonRect.top - settingsRect.top + tooltipOffsetY;

            errorTooltip.style.left = left + 'px';
            errorTooltip.style.top = top + 'px';
            errorTooltip.style.transform = 'translateX(-50%) translateY(-100%)';

            errorTooltip.classList.add('show');
          }, CONFIG.ERROR_TOOLTIP_DELAY);
        });

        importButton.addEventListener('mouseleave', () => {
          if (errorTimeout) {
            clearTimeout(errorTimeout);
            errorTimeout = null;
          }
          errorTooltip.classList.remove('show');
        });
      }

      /**
       * Initialize drag controls for numeric inputs
       * @private
       */
      _initializeDragControls() {
        const contrastRow = this.elements.contrastInput.closest('.input-row');
        const countRow = this.elements.colorCount.closest('.input-row');

        const contrastIcon = contrastRow.querySelector('svg');
        const countIcon = countRow.querySelector('svg');

        this._addDragToIcon(contrastIcon, {
          input: this.elements.contrastInput,
          min: CONFIG.CONTRAST_MIN,
          max: CONFIG.CONTRAST_MAX,
          step: CONFIG.CONTRAST_STEP,
          checkBlocked: () => this.state.features.smartSpacing,
          onUpdate: (value) => {
            this.state.contrast = value;
            if (value !== 1.0 && this.state.features.smartSpacing) {
              this._toggleFeatureButton('smartSpacing', false);
            }
            this._regenerateColors();
          }
        });

        this._addDragToIcon(countIcon, {
          input: this.elements.colorCount,
          min: CONFIG.COLOR_COUNT_MIN,
          max: CONFIG.COLOR_COUNT_MAX,
          step: 1,
          checkBlocked: () => false,
          onUpdate: (value) => {
            this.state.colorCount = value;
            this._regenerateColors();
          }
        });
      }

      /**
       * Add drag functionality to icon
       * @param {HTMLElement} icon - Icon element
       * @param {Object} config - Drag configuration
       * @private
       */
      _addDragToIcon(icon, config) {
        if (!icon || !config.input) return;

        let dragState = { active: false, startX: 0, startValue: 0 };
        const cursorBlockedTimeout = 150;

        const updateCursor = () => {
          icon.style.cursor = (config.checkBlocked && config.checkBlocked())
            ? 'not-allowed'
            : 'ew-resize';
        };

        icon.addEventListener('mouseenter', updateCursor);
        icon.updateCursor = updateCursor;

        icon.addEventListener('mousedown', (e) => {
          e.preventDefault();

          if (config.checkBlocked && config.checkBlocked()) {
            document.body.style.cursor = 'not-allowed';
            setTimeout(() => document.body.style.cursor = '', cursorBlockedTimeout);
            return;
          }

          dragState.active = true;
          dragState.startX = e.clientX;
          dragState.startValue = parseFloat(config.input.value);

          document.body.style.cursor = 'ew-resize';
          document.body.style.userSelect = 'none';

          const handleMouseMove = (e) => {
            if (!dragState.active) return;

            const deltaX = e.clientX - dragState.startX;
            const sensitivity = config.step * CONFIG.DRAG_SENSITIVITY;
            const newValue = dragState.startValue + (deltaX * sensitivity);

            const clampedValue = Math.max(config.min, Math.min(config.max, newValue));
            const steppedValue = Math.round(clampedValue / config.step) * config.step;
            const finalValue = parseFloat(steppedValue.toFixed(1));

            config.input.value = finalValue;
            config.onUpdate(finalValue);
          };

          const handleMouseUp = () => {
            dragState.active = false;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';

            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
          };

          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
        });
      }

      /**
       * Update drag controls state (cursor style)
       * @private
       */
      _updateDragControlsState() {
        const contrastRow = this.elements.contrastInput.closest('.input-row');
        const contrastIcon = contrastRow?.querySelector('svg');
        if (contrastIcon && contrastIcon.updateCursor) {
          contrastIcon.updateCursor();
        }
      }

      /**
       * Toggle feature button state
       * @param {string} feature - Feature name
       * @param {boolean} active - Active state
       * @private
       */
      _toggleFeatureButton(feature, active) {
        const button = document.querySelector(`[data-feature="${feature}"]`);
        if (button) {
          if (active) {
            button.classList.add('active');
          } else {
            button.classList.remove('active');
          }
          this.state.setFeature(feature, active);
        }
      }

      /**
       * Initialize input validation
       * @private
       */
      _initializeInputValidation() {
        this._setupHexValidation();
        this._setupRgbValidation();
        this._setupFocusOutlines();
      }

      /**
       * Setup HEX input validation
       * @private
       */
      _setupHexValidation() {
        const colorInputContainer = this.elements.colorValue.closest('.color-input');
        const validationDelay = 300;

        const validateHex = (value) => {
          if (this.state.features.rgbFormat) return true;
          if (!value) return true;

          const hexValue = value.replace(/^#/, '');
          return /^[0-9A-Fa-f]{6}$/.test(hexValue);
        };

        const updateValidationState = () => {
          const isValid = validateHex(this.elements.colorValue.value.trim());
          colorInputContainer.classList.toggle('error', !isValid);
        };

        this.elements.colorValue.addEventListener('input', () => {
          if (this.state.features.rgbFormat) {
            colorInputContainer.classList.remove('error');
            return;
          }

          clearTimeout(window.hexValidationTimeout);
          window.hexValidationTimeout = setTimeout(updateValidationState, validationDelay);
        });

        this.elements.colorValue.addEventListener('blur', () => {
          if (!this.state.features.rgbFormat) {
            clearTimeout(window.hexValidationTimeout);
            updateValidationState();
          }
        });

        this.elements.colorValue.addEventListener('focus', () => {
          if (!this.state.features.rgbFormat) {
            updateValidationState();
          }
        });
      }

      /**
       * Setup RGB input validation
       * @private
       */
      _setupRgbValidation() {
        const maxDigits = 3;
        const maxRgbValue = 255;
        const minRgbComponents = 3;

        this.elements.colorValue.addEventListener('input', (e) => {
          if (!this.state.features.rgbFormat) return;

          let value = e.target.value;
          let cursorPos = e.target.selectionStart;
          let originalLength = value.length;

          value = value.replace(/[^0-9\s,\.]/g, '');

          let parts = value.split(/[\s,\.]+/);
          let processedParts = [];

          for (let i = 0; i < parts.length; i++) {
            let part = parts[i];

            if (part === '') {
              processedParts.push('');
              continue;
            }

            if (part.length > maxDigits) {
              part = part.substring(0, maxDigits);
            }

            let num = parseInt(part);
            if (!isNaN(num) && num > maxRgbValue) {
              part = maxRgbValue.toString();
            }

            processedParts.push(part);
          }

          let separators = value.match(/[\s,\.]+/g) || [];
          let result = processedParts[0] || '';
          for (let i = 0; i < separators.length && i < processedParts.length - 1; i++) {
            result += separators[i] + (processedParts[i + 1] || '');
          }

          if (result !== e.target.value) {
            e.target.value = result;
            let lengthDiff = result.length - originalLength;
            let newCursorPos = Math.max(0, cursorPos + lengthDiff);
            e.target.setSelectionRange(newCursorPos, newCursorPos);
          }
        });

        this.elements.colorValue.addEventListener('blur', (e) => {
          if (!this.state.features.rgbFormat) return;

          let value = e.target.value.trim();
          if (!value) return;

          let numbers = value.replace(/[^\d\s,\.]/g, '').split(/[\s,\.]+/).filter(n => n);

          let correctedNumbers = numbers.slice(0, minRgbComponents).map(num => {
            let n = parseInt(num);
            return isNaN(n) ? 0 : Math.min(maxRgbValue, Math.max(0, n));
          });

          while (correctedNumbers.length < minRgbComponents) {
            correctedNumbers.push(0);
          }

          e.target.value = correctedNumbers.join(', ');
        });
      }

      /**
       * Setup focus outline effects for inputs
       * @private
       */
      _setupFocusOutlines() {
        const colorValueInputs = document.querySelectorAll('.color-value');

        colorValueInputs.forEach(input => {
          input.addEventListener('focus', function () {
            const parent = this.closest('.color-input, .contrast-input');
            if (parent) {
              parent.classList.add('focused');
            }
          });

          input.addEventListener('blur', function () {
            const parent = this.closest('.color-input, .contrast-input');
            if (parent) {
              parent.classList.remove('focused');
            }
          });
        });
      }
    }

    // ============================================================================
    // PRESET MANAGER
    // Manages preset color palettes
    // ============================================================================

    class PresetManager {
      constructor(state) {
        this.state = state;
        this.presets = PRESET_DATA;
        this._renderPresets();
        this._initializeEventListeners();
      }

      /**
       * Render preset items in the UI
       * @private
       */
      _renderPresets() {
        const presetsContainer = document.querySelector('.presets-section');
        if (!presetsContainer) return;

        presetsContainer.innerHTML = '';

        Object.entries(this.presets).forEach(([id, preset]) => {
          const presetElement = this._createPresetElement(id, preset);
          presetsContainer.appendChild(presetElement);
        });
      }

      /**
       * Create preset element
       * @param {string} id - Preset identifier
       * @param {Object} preset - Preset configuration
       * @returns {HTMLElement} Preset DOM element
       * @private
       */
      _createPresetElement(id, preset) {
        const item = document.createElement('div');
        item.className = 'preset-item';
        item.dataset.preset = id;

        const previewColors = this._generatePreviewColors(preset);
        const hsv = ColorMath.hexToHsv(preset.color);
        const hoverColor = ColorMath.getDesaturatedColor(
          hsv.h,
          hsv.s,
          hsv.v,
          preset.saturation
        );

        const isGrayPreset = preset.saturation < CONFIG.SATURATION_MAX;

        item.innerHTML = `
          <div class="preset-spectrum">
            ${previewColors.map(color =>
          `<div class="spectrum-color" style="background: ${color};"></div>`
        ).join('')}
          </div>
          <div class="preset-info" style="background: ${hoverColor};">
            <span class="preset-name">${preset.name}</span>
            ${isGrayPreset ? `
              <div class="preset-contrast-container preset-saturation-container">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M21 15.5217V13.459M21 10.5405V8.29297M13 21H15.3949M15.2001 3H13.0014M18.5946 20.3586C19.3791 19.9499 19.9882 19.3272 20.3804 18.5586M20.2975 5.28654C19.864 4.53735 19.2343 3.94384 18.4395 3.54492" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M10 3H7C4.79086 3 3 4.79086 3 7V17C3 19.2091 4.79086 21 7 21H10V3Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span class="preset-saturation">${preset.saturation}%</span>
              </div>
            ` : `
              <div class="preset-contrast-container">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M21.1836 12.9453C21.1836 7.9744 17.1545 3.94531 12.1846 3.94531C7.21463 3.94531 3.18555 7.9744 3.18555 12.9453C3.18555 17.9153 7.21463 21.9444 12.1846 21.9444C17.1545 21.9444 21.1836 17.9153 21.1836 12.9453Z"
                    stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M12.1309 20.8749L21.1301 11.9922" stroke="currentColor" stroke-width="1.5"
                    stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M17.3949 5.60938L12.209 10.7369" stroke="currentColor" stroke-width="1.5"
                    stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M12.1602 15.8258L19.8462 8.2168" stroke="currentColor" stroke-width="1.5"
                    stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M12.1211 3.94531V21.9444" stroke="currentColor" stroke-width="1.5"
                    stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span class="preset-contrast">${preset.contrast}</span>
              </div>
            `}
            <span class="preset-hex">${preset.color}</span>
          </div>
        `;

        return item;
      }

      /**
       * Generate preview colors for preset
       * @param {Object} preset - Preset configuration
       * @returns {Array} Array of HEX color strings
       * @private
       */
      _generatePreviewColors(preset) {
        const hsv = ColorMath.hexToHsv(preset.color);
        const previewColorCount = 10;

        const { colors } = ColorGenerator.generatePalette({
          hue: hsv.h,
          saturation: hsv.s,
          value: hsv.v,
          colorCount: previewColorCount,
          contrast: preset.contrast,
          smartSpacing: false,
          includeBlackWhite: false,
          saturationControl: preset.saturation
        });

        return colors.map(c => c.hex).reverse();
      }

      /**
       * Initialize event listeners for presets
       * @private
       */
      _initializeEventListeners() {
        const scaleAnimationDuration = 100;
        const scalePressed = 0.98;
        const scaleNormal = 1;

        document.querySelectorAll('.preset-item').forEach(item => {
          const presetId = item.dataset.preset;
          if (!presetId) return;

          item.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();

            const preset = this.presets[presetId];
            if (preset) {
              this.state.applyPreset(preset);

              item.style.transform = `scale(${scalePressed})`;
              setTimeout(() => {
                item.style.transform = `scale(${scaleNormal})`;
              }, scaleAnimationDuration);
            }
          });

          item.style.cursor = 'pointer';
        });
      }
    }

    // ============================================================================
    // APPLICATION INITIALIZATION
    // Main entry point
    // ============================================================================

    class Application {
      constructor() {
        this.state = new AppState();
        this.ui = null;
        this.presetManager = null;
      }

      /**
       * Initialize the application
       */
      initialize() {
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => this._setup());
        } else {
          this._setup();
        }
      }

      /**
       * Setup application components
       * @private
       */
      _setup() {
        this.ui = new UIController(this.state);
        this.presetManager = new PresetManager(this.state);
        this._performInitialRender();

        console.log(' Shade Perfection initialized successfully');
      }

      /**
       * Perform initial render
       * @private
       */
      _performInitialRender() {
        this.ui.colorPicker.updateVisuals();
        this.ui.colorPicker.drawCurve();
        this.ui.colorPicker.drawDesaturatedCurve();

        const { colors, curvePoints } = ColorGenerator.generatePalette({
          hue: this.state.hue,
          saturation: this.state.saturation,
          value: this.state.value,
          colorCount: this.state.colorCount,
          contrast: this.state.contrast,
          smartSpacing: this.state.features.smartSpacing,
          includeBlackWhite: this.state.features.includeBlackWhite,
          saturationControl: this.state.saturationControl
        });

        this.state.updateGeneratedColors(colors, curvePoints);

        const importButton = document.getElementById('importButton');
        if (importButton) {
          importButton.disabled = true;
        }
      }
    }

    // ============================================================================
    // START APPLICATION
    // ============================================================================

    const app = new Application();
    app.initialize();

  </script>
</body>

</html>